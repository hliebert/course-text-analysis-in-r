Robust Synthetic Control∗
Muhammad Jehangir Amjad, Devavrat Shah, and Dennis Shen

arXiv:1711.06940v1 [econ.EM] 18 Nov 2017

Laboratory for Information and Decision Systems,
Statistics and Data Science Center,
Massachusetts Institute of Technology
{mamjad, devavrat, deshen}@mit.edu

Abstract

We present a robust generalization of the synthetic control method for comparative case
studies. Like the classical method cf. [1, 4, 2], we present an algorithm to estimate the
unobservable counterfactual of a treatment unit. A distinguishing feature of our algorithm
is that of de-noising the data matrix via singular value thresholding, which renders our
approach robust in multiple facets: it automatically identifies a good subset of donors for
the synthetic control, overcomes the challenges of missing data, and continues to work
well in settings where covariate information may not be provided. To begin with, we
establish the condition under which the fundamental assumption in synthetic control-like
approaches holds, i.e. when the linear relationship between the treatment unit and the
donor pool prevails in both the pre- and post-intervention periods. We provide the first
finite sample analysis (coupled with asymptotic results) for a broader class of models,
the Latent Variable Model (LVM), in contrast to Factor Models previously considered
in the literature, while also relating the interpolation and extrapolation abilities of our
estimator to the amount of data available. In particular, we show that our de-noising
procedure accurately imputes missing entries and filters corrupted observations in producing
a consistent estimator of the underlying signal matrix, provided p = Ω(T −1+ζ ) for some
ζ > 0; here, p is the fraction of observed data and T is the time interval of interest.
Under the same proportion of observations, we demonstrate
that the mean-squared-error
√
in our prediction estimation scales as O(σ 2 /p + 1/ T ), where σ 2 is the variance of the
inherent noise. Using a “data aggregation” method, we show that the mean-square-error
can be made as small as O(T −1/2+γ ) for any γ ∈ (0, 1/2), and thus leading to a consistent
estimator. In order to move beyond point estimates, we introduce a Bayesian framework
that not only provides the ability to readily develop different estimators under various loss
functions, but also quantifies the uncertainty of the model/estimates through posterior
probabilities. Our experiments, using both synthetic and real-world datasets, demonstrate
that our robust generalization yields an improvement over the classical synthetic control
method, underscoring the value of our key de-noising procedure.
∗ We

would like to thank Alberto Abadie for careful reading and comments that have helped in improving the manuscript.

1

1

Introduction

On November 8, 2016 in the aftermath of several high profile mass-shootings, voters in California passed
Proposition 63 in to law [10]. Prop. 63 “outlaw[ed] the possession of ammunition magazines that [held]
more than 10 rounds, requir[ed] background checks for people buying bullets,” and was proclaimed as
an initiative for “historic progress to reduce gun violence” [30]. Imagine that we wanted to study the
impact of Prop. 63 on the rates of violent crime in California. Randomized control trials, such as A/B
testings, have been successful in establishing effects of interventions by randomly exposing segments
of the population to various types of interventions. Unfortunately, a randomized control trial is not
applicable in this scenario since only one California exists. Instead, a statistical comparative study
could be conducted where the rates of violent crime in California are compared to a “control” state
after November 2016, which we refer to as the post-intervention period. To reach a statistically valid
conclusion, however, the control state must be demonstrably similar to California sans the passage of a
Prop. 63 style legislation. In general, there may not exist a natural control state for California, and
subject-matter experts tend to disagree on the most appropriate state for comparison.
As a suggested remedy to overcome the limitations of a classical comparative study outlined above,
Abadie et al. proposed a powerful, data-driven approach to construct a “synthetic” control unit absent of
intervention [1, 4, 2]. In the example above, the synthetic control method would construct a “synthetic”
state of California such that the rates of violent crime of that hypothetical state would best match
the rates in California before the passage of Prop. 63. This synthetic California can then serve as
a data-driven counterfactual for the period after the passage of Prop. 63. Abadie et al. propose
to construct such a synthetic California by choosing a convex combination of other states (donors)
in the United States. For instance, synthetic California might be 80% like New York and 20% like
Massachusetts. This approach is nearly entirely data-driven and appeals to intuition. For optimal results,
however, the method still relies on subjective covariate information, such as employment rates, and the
presence of domain “experts” to help identify a useful subset of donors. The approach may also perform
poorly in the presence of non-negligible levels of noise and missing data.

1.1

Overview of main contributions.

As the main result, we propose a simple, two-step robust synthetic control algorithm, wherein the
first step de-noises the data and the second step learns a linear relationship between the treated unit
and the donor pool under the de-noised setting. The algorithm is robust in two senses: first, it is
fully data-driven in that it is able to find a good donor subset even in the absence of helpful domain
knowledge or supplementary covariate information; and second, it provides the means to overcome the
challenges presented by missing and/or noisy observations. As another important contribution, we
establish analytic guarantees (finite sample analysis and asymptotic consistency) – that are missing from
the literature – for a broader class of models.
Robust algorithm. A distinguishing feature of our work is that of de-noising the observation
data via singular value thresholding. Although this spectral procedure is commonplace in the matrix
completion arena, it is novel in the realm of synthetic control. Despite its simplicity, however, thresholding
brings a myriad of benefits and resolves points of concern that have not been previously addressed. For
instance, while classical methods have not even tackled the obstacle of missing data, our approach is
well equipped to impute missing values as a consequence of the thresholding procedure. Additionally,
thresholding can help prevent the model from overfitting to the idiosyncrasies of the data, providing
a knob for practitioners to tune the “bias-variance” trade-off of their model and, thus, reduce their
mean square error (MSE). From empirical studies, we hypothesize that thresholding may possibly render
auxiliary covariate information (vital to several existing methods) a luxury as opposed to a necessity.
However, as one would expect, the algorithm can only benefit from useful covariate and/or “expert”
information and we do not advocate ignoring such helpful information, if available.

2

In the spirit of combatting overfitting, we extend our algorithm to include regularization techniques
such as ridge regression and LASSO. We also move beyond point estimates in establishing a Bayesian
framework, which allows one to quantitatively compute the uncertainty of the results through posterior
probabilities.
Theoretical performance. To the best of our knowledge, ours is the first to provide finite sample
analysis of the MSE for the synthetic control method, in addition to guarantees in the presence of
missing data. Previously, the main theoretical result from the synthetic control literature (cf. [1, 4, 2])
pertained to bounding the bias of the synthetic control estimator; however, the proof of the result
assumed that the latent parameters, which live in the simplex, have a perfect pre-treatment match in
the noisy predictor variables – our analysis, on the other hand, removes this assumption. We begin by
demonstrating that our de-noising procedure produces a consistent estimator of the latent signal matrix
(Theorems 4.1, 4.2), proving that our thresholding method accurately imputes and filters missing and
noisy observations, respectively. We then provide finite sample analysis that not only highlights the
value of thresholding in balancing the inherent “bias-variance” trade-off of forecasting, but also proves
that the prediction efficacy of our algorithm degrades gracefully with an increasing number of randomly
missing data (Theorems 4.3, 4.6, and Corollary 4.1). Further, we show that a computationally beneficial
pre-processing data aggregation step allows us to establish the asymptotic consistency of our estimator
in generality (Theorem 4.4).
Additionally, we prove a simple linear algebraic fact that justifies the basic premise of synthetic
control, which has not been formally established in literature, i.e. the linear relationship between the
treatment and donor units that exists in the pre-intervention continues to hold in post-intervention
period (Theorem 4.5). We introduce a latent variable model, which subsumes many of the models
previously used in literature (e.g. econometric factor models). Despite this generality, a unifying theme
that connects these models is that they all induce (approximately) low rank matrices, which is well
suited for our method.
Experimental results. We conduct two sets of experiments: (a) on existing case studies from real
world datasets referenced in [1, 2, 4], and (b) on synthetically generated data. Remarkably, while [1, 2, 4]
use numerous covariates and employ expert knowledge in selecting their donor pool, our algorithm
achieves similar results without any such assistance; additionally, our algorithm detects subtle effects of
the intervention that were overlooked by the original synthetic control approach. Since it is impossible
to simultaneously observe the evolution of a treated unit and its counterfactual, we employ synthetic
data to validate the efficacy of our method. Using the MSE as our evaluation metric, we demonstrate
that our algorithm is robust to varying levels of noise and missing data, reinforcing the importance of
de-noising.

1.2

Related work.

Synthetic control has received widespread attention since its conception by Abadie and Gardeazabal in
their pioneering work [4, 1]. It has been employed in numerous case studies, ranging from criminology
[31] to health policy [27] to online advertisement to retail; other notable studies include [3, 11, 5, 9]. In
their paper on the state of applied econometrics for causality and policy evaluation, Athey and Imbens
assert that synthetic control is “one of the most important development[s] in program evaluation in the
past decade” and “arguably the most important innovation in the evaluation literature in the last fifteen
years” [8]. In a somewhat different direction, Hsiao et al. introduce the panel data method [24, 25],
which seems to have a close bearing with some of the approaches of this work. In particular, [24, 25] only
uses data for the outcome variable and solves an ordinary least squares problem in learning synthetic
control. However, [24, 25] restrict the subset of possible controls to units that are within the geographical
or economic proximity of the treated unit. Therefore, there is still some degree of subjectivity in the
choice of the donor pool. In addition, [24, 25] do not include a “de-noising” step, which is a key feature
of our approach. For an empirical comparison between the synthetic control and panel data methods,
3

see [21]. It should be noted that [21] also adapts the panel data method to automate the donor selection
process. [17] allows for an additive difference between the treated unit and donor pool, similar to the
difference-in-differences (DID) method. Moreover, similar to our exposition, [17] relaxes the convexity
aspect of synthetic control and proposes an algorithm that allows for unrestricted linearity as well
as regularization. In an effort to infer the causal impact of market interventions, [14] introduce yet
another evaluation methodology based on a diffusion-regression state-space model that is fully Bayesian;
similar to [1, 4, 24, 25], their model also generalizes the DID procedure. Due to the subjectivity in the
choice of covariates and predictor variables, [20] provides recommendations for specification-searching
opportunities in synthetic control applications. The recent work of [34] extends the synthetic control
method to allow for multiple treated units and variable treatment periods as well as the treatment being
correlated with unobserved units. Similar to our work, [34] computes uncertainty estimates; however,
while [34] obtains these measurements via a parametric bootstrap procedure, we obtain uncertainty
estimates under a Bayesian framework.
Matrix completion and factorization approaches are well-studied problems with broad applications
(e.g. recommendation systems, graphon estimation, etc.). As shown profusely in the literature, spectral
methods, such as singular value decomposition and thresholding, provide a procedure to estimate
the entries of a matrix from partial and/or noisy observations [15]. With our eyes set on achieving
“robustness”, spectral methods become particularly appealing since they de-noise random effects and
impute missing information within the data matrix [26]. For a detailed discussion on the topic, see
[16]; for algorithmic implementations, see [29] and references there in. We note that our goal differs
from traditional matrix completion applications in that we are using spectral methods to estimate a
low-rank matrix, allowing us to determine a linear relationship between the rows of the mean matrix.
This relationship is then projected into the future to determine the counterfactual evolution of a row in
the matrix (treated unit), which is traditionally not the goal in matrix completion applications. Another
line of work within this arena is to impute the missing entries via a nearest neighbor based estimation
algorithm under a latent variable model framework [28, 13].
There has been some recent work in using matrix norm methods in relation to causal inference,
including for synthetic control. In [7], the authors use matrix norm regularization techniques to estimate
counterfactuals for panel data under settings that rely on the availability of a large number of units
relative to the number of factors or characteristics, and under settings that involve limited number of
units but plenty of history (synthetic control). This is different from our approach, which increases
robustness by “de-noising” using matrix completion methods, and then using linear regression on the
de-noised matrix, instead of relying on matrix norm regularizations.
Despite its popularity, there has been less theoretical work in establishing the consistency of the
synthetic control method or its variants. [1] demonstrates that the bias of the synthetic control estimator
can be bounded by a function that is close to zero when the pre-intervention period is large in relation
to the scale of the transitory shocks, but under the additional condition that a perfect convex match
between the pre-treatment noisy outcome and covariate variables for the treated unit and donor pool
exists. [19] relaxes the assumption in [1], and derives conditions under which the synthetic control
estimator is asymptotically unbiased under non-stationarity conditions. To our knowledge, however, no
prior work has provided finite-sample analysis, analyzed the performance of these estimators with respect
to the mean-squared error (MSE), established asymptotic consistency, or addressed the possibility of
missing data, a common handicap in practice.

4

2

Background

2.1

Notation.

We will denote R as the field of real numbers. For any positive integer N , let [N ] = {1, . . . , N }. For
Pn
2
2
any vector v ∈ Rn , we denote its Euclidean (`2 ) norm by kvk2 , and define kvk2 =
i=1 vi . We
define its infinity norm as kvk∞ = maxi |vi |. In general, the `p norm for a vector v is defined as
P
1/p
n
p
|v
|
kvkp =
. Similarly, for an m × n real-valued matrix A = [Aij ], its spectral/operator
i
i=1
norm, denoted by kAk2 , is defined as kAk2 = max1≤i≤k |σi |, where k = min{m, n} and σi are the
singular values of A. The Moore-Penrose pseudoinverse A† of A is defined as
A† =

k
X

(1/σi )yi xTi ,

where

A=

i=1

k
X

σi xi yiT ,

(1)

i=1

with xi and yi being the left and right singular vectors of A, respectively. We will adopt the shorthand
notation of k·k ≡ k·k2 . To avoid any confusions between scalars/vectors and matrices, we will represent
all matrices in bold, e.g. A.
Let f and g be two functions defined on the same space. We say that f (x) = O(g(x)) and
f (x) = Ω(g(x)) if and only if there exists a positive real number M and a real number x0 such that for
all x ≥ x0 ,
|f (x)| ≤ M |g(x)| and |f (x)| ≥ M |g(x)|,

(2)

respectively.

2.2

Model.

The data at hand is a collection of time series with respect to an aggregated metric of interest (e.g.
violent crime rates) comprised of both the treated unit and the donor pool outcomes. Suppose we observe
N ≥ 2 units across T ≥ 2 time periods. We denote T0 as the number of pre-intervention periods with
1 ≤ T0 < T , rendering T − T0 as the length of the post-intervention stage. Without loss of generality, let
the first unit represent the treatment unit – exposed to the intervention of interest at time t = T0 + 1.
The remaining donor units, 2 ≤ i ≤ N , are unaffected by the intervention for the entire time period
[T ] = {1, . . . , T }.
Let Xit denote the measured value of metric for unit i at time t. We posit
Xit = Mit + it ,

(3)

where Mit is the deterministic mean while the random variables it represent zero-mean noise that are
independent across i, t. Following the philosophy of latent variable models [16, 28, 6, 22, 23], we further
posit that for all 2 ≤ i ≤ N , t ∈ [T ]
Mit = f (θi , ρt ),

(4)

where θi ∈ Rd1 and ρt ∈ Rd2 are latent feature vectors capturing unit and time specific information,
respectively, for some d1 , d2 ≥ 1; the latent function f : Rd1 × Rd2 → R captures the model relationship.
We note that this formulation subsumes popular econometric factor models, such as the one presented
in [1], as a special case with (small) constants d1 = d2 and f as a bilinear function.
The treatment unit obeys the same model relationship during the pre-intervention period. That is,
for t ≤ T0
X1t = M1t + 1t ,
5

(5)

where M1t = f (θ1 , ρt ) for some latent parameter θ1 ∈ Rd1 . If unit one was never exposed to the
intervention, then the same relationship as (5) would continue to hold during the post-intervention
period as well. In essence, we are assuming that the outcome random variables for all unaffected
units follow the model relationship defined by (5) and (3). Therefore, the “synthetic control” would
ideally help estimate the underlying counterfactual means M1t = f (θ1 , ρt ) for T0 < t ≤ T by using an
appropriate combination of the post-intervention observations from the donor pool since the donor units
are immune to the treatment.
To render this feasible, we make the key operating assumption (as done in literature cf. [1, 2, 4]) that
the mean vector of the treatment unit over the pre-intervention period, i.e. the vector M1− = [M1t ]t≤T0 ,
lies within the span of the mean vectors within the donor pool over the pre-intervention period, i.e. the
span of the donor mean vectors Mi− = [Mit ]2≤i≤N,t≤T0 1 . More precisely, we assume there exists a set
of weights β ∗ ∈ RN −1 such that for all t ≤ T0 ,
M1t =

N
X

βi∗ Mit .

(6)

i=2

This is a reasonable and intuitive assumption, utilized in literature, hypothesizing that the treatment
unit can be modeled as some combination of the donor pool. In fact, the set of weights β ∗ are the very
definition of a synthetic control.
In order to distinguish the pre- and post-intervention periods, we use the following notation for all
(donor) matrices: A = [A− , A+ ], where A− = [Aij ]2≤i≤N,j∈[T0 ] and A+ = [Aij ]2≤i≤N,T0 <j≤T denote
the pre- and post-intervention submatrices, respectively; vectors will be defined in the same manner,
+
−
+
i.e. Ai = [A−
i , Ai ], where Ai = [Ait ]t∈[T0 ] and Ai = [Ait ]T0 <t≤T denote the pre- and post-intervention
subvectors, respectively, for the ith donor. Moreover, we will denote all vectors related to the treatment
+
unit with the subscript “1”, e.g. A1 = [A−
1 , A1 ].
In contrast with the classical synthetic control work, we allow our model to be robust to incomplete
observations. To model randomly missing data, the algorithm observes each data point Xit in the
donor pool with probability p ∈ (0, 1], independently of all other entries. While the assumption that
p is constant across all rows and columns of our observation matrix is standard in literature, our
results remain valid even in situations where the probability of observation is dependent on the row
and column latent parameters, i.e. pij = g(θi , ρj ) ∈ (0, 1]. In such situations, pij can be estimated as
p̂ij using consistent graphon estimation techniques described in a growing body of literature, e.g. see
[13, 16, 33, 35]. These estimates can then be used in our analysis presented in Section 4.

3
3.1

Algorithm
Intuition.

We begin by exploring the intuition behind our proposed two-step algorithm: (1) de-noising the data:
since the singular values of our observation matrix, X = [Xit ]2≤i≤N,t∈[T ] , encode both signal and noise,
we aim to discover a low rank approximation of X that only incorporates the singular values associated
with useful information; simultaneously, this procedure will naturally impute any missing observations.
We note that this procedure is similar to the algorithm proposed in [16]. (2) learning β ∗ : using the
pre-intervention portion of the de-noised matrix, we learn the linear relationship between the treatment
unit and the donor pool prior to estimating the post-intervention counterfactual outcomes. Since our
objective is to produce accurate predictions, it is not obvious why the synthetic treatment unit should
1 We note that this is a minor departure from the literature on synthetic control starting in [4] – in literature, the
pre-intervention noisy observation (rather than the mean) vector X1 , is assumed to be a convex (rather than linear)
combination of the noisy donor observations. We believe our setup is more reasonable since we do not want to fit noise.

6

be a convex combination of its donor pool as assumed in [1, 4, 3]. In fact, one can reasonably expect
that the treatment unit and some of the donor units may exhibit negative correlations with one another.
In light of this intuition, we learn the optimal set of weights via linear regression, allowing for both
positive and negative elements.

3.2

Robust algorithm (algorithm 1).

We present the details of our robust method in Algorithm 1 below. The algorithm utilizes two
hyperparameters: (1) a thresholding hyperparameter µ ≥ 0, which serves as a knob to effectively
trade-off between the bias and variance of the estimator, and (2) a regularization hyperameter η ≥ 0
that controls the model complexity. We discuss the procedure for determining the hyperparameters in
Section 3.4. To simplify the exposition, we assume the entries of X are bounded by one in absolute
value, i.e. |Xit | ≤ 1.
Algorithm 1 Robust synthetic control
Step 1. De-noising the data: singular value thresholding (inspired by [16]).
1. Define Y = [Yit ]2≤i≤N,t∈[T ] with
(
Xit
Yit =
0

if Xit is observed,
otherwise.

(7)

2. Compute the singular value decomposition of Y :
Y =

N
−1
X

si ui viT .

(8)

i=1

3. Let S = {i : si ≥ µ} be the set of singular values above the threshold µ.
4. Define the estimator of M as
1X
M̂ =
si ui viT ,
p̂

(9)

i∈S

where p̂ is the maximum of the fraction of observed entries in X and

1
(N −1)T

.

Step 2. Learning and projecting
1. For any η ≥ 0, let
β̂(η) = arg min Y1− − (M̂ − )T v

2

2

+ ηkvk .

(10)

v∈RN −1

2. Define the counterfactual means for the treatment unit as
M̂1 = M̂ T β̂(η).

7

(11)

3.3

Bayesian algorithm: measuring uncertainty (algorithm 2).

In order to quantitatively assess the uncertainty of our model, we will transition from a frequentist
perspective to a Bayesian viewpoint. As commonly assumed in literature, we consider a zero-mean,
isotropic Gaussian noise model (i.e.  ∼ N (0, σ 2 I)) and use the square loss for our cost function. We
present the Bayesian method as Algorithm 2. Note that we perform step one of our robust algorithm
exactly as in Algorithm 1; as a result, we only detail the alterations of step two in the Bayesian version
(Algorithm 2).
Algorithm 2 Bayesian robust synthetic control
Step 2. Learning and projecting
1. Estimate the noise variance via (bias-corrected) maximum likelihood, i.e.
T

σ̂ 2 =

0
1 X
(Y1t − Ȳ )2 ,
T0 − 1 t=1

(12)

where Ȳ denotes the pre-intervention sample mean.
2. Compute posterior distribution parameters for an appropriate choice of the prior α:
1
−1
−
− T
M̂
(
M̂
)
+
αI
σ̂ 2
1
= 2 ΣD M̂ − Y1− .
σ̂

ΣD =

(13)

βD

(14)

3. Define the counterfactual means for the treatment unit as
M̂1 = M̂ T βD .

(15)

4. For each time instance t ∈ [T ], compute the model uncertainty (variance) as
2
T
σD
(M̂·,t ) = σ̂ 2 + M̂·,t
ΣD M̂·,t ,

(16)

where M̂·,t = [M̂it ]2≤i≤N is the de-noised vector of donor outcomes at time t.

3.4
3.4.1

Algorithmic features: the fine print.
Bounded entries transformation.

Several of our results, as well as the algorithm we propose, assume that the observation matrix is bounded
such that |Xit | ≤ 1. For any data matrix, we can achieve this by using the following pre-processing
transformation: suppose the entries of X belong to an interval [a, b]. Then, one can first pre-process the
matrix X by subtracting (a + b)/2 from each entry, and dividing by (b − a)/2 to enforce that the entries
lie in the range [−1, 1]. The reverse transformation, which can be applied at the end of the algorithm
description above, returns a matrix with values contained in the original range. Specifically, the reverse
transformation equates to multiplying the end result by (b − a)/2 and adding by (a + b)/2.

8

3.4.2

Solution interpretability.

For the practitioner who seeks a more interpretable solution, e.g. a convex combination of donors as
per the original synthetic control estimator of Abadie et. al, we recommend using an `1 -regularization
penalty in the learning procedure of step 2. Due to the geometry of LASSO, the resulting estimator will
be often be a sparse vector. Specifically, for any η > 0, we define the LASSO estimator to be
β̂(η) = arg min Y1− − (M̂ − )T v
v∈RN −1

3.4.3

2

+ ηkvk1 .

Choosing the hyperparameters.

Here, we discuss several approaches to choosing the hyperparameter µ for the singular values. If it is
known a priori that the underlying model is low rank with rank at most k, then it may make sense
to choose µ such that |S| = k. A data driven approach, however, could be implemented based on
cross-validation. Precisely, reserve a portion of the pre-intervention period for validation, and use the
rest of the pre-intervention data to produce an estimate β̂(η) for each of the finitely many choices of µ
(s1 , . . . , sN −1 ). Using each estimate β̂(η), produce its corresponding treatment unit mean vector over the
validation period. Then, select the µ that achieves the minimum MSE with respect to the observed data.
Finally, [16] provides a universal approach to picking a threshold; similarly, we also propose another
such universal threshold, (20), in Section 4.1. We utilize the data driven approach in our experiments in
this work.
The regularization parameter, η, also plays a crucial role in learning the synthetic control and
influences both the training and generalization errors. As is often the case in model selection, a popular
strategy in estimating the ideal η is to employ cross-validation as described above. However, since
time-series data often have a natural temporal ordering with causal effects, we also recommend employing
the forward chaining strategy. Although the forward chaining strategy is similar to leave-one-out (LOO)
cross-validation, an important distinction is that forward chaining does not break the temporal ordering
in the training data. More specifically, for a particular candidate of η at every iteration t ∈ [T0 ], the
learning process uses [Y11 , . . . , Y1,t−1 ] as the training portion while reserving Y1t as the validation point.
As before, the average error is then computed and used to evaluate the model (characterized by the
choice of η). The forward chaining strategy can also be used to learn the optimal µ.
3.4.4

Scalability.

In terms of scalability, the most computationally demanding procedure is that of evaluating the singular
value decomposition (SVD) of the observation matrix. Given the ubiquity of SVD methods in the realm
of machine learning, there are well-known techniques that enable computational and storage scaling
for SVD algorithms. For instance, both Spark (through alternative least squares) and Tensor-Flow
come with built-in SVD implementations. As a result, by utilizing the appropriate computational
infrastructure, our de-noising procedure, and algorithm in generality, can scale quite well. Also note
that for a low rank structure, we typically only need to compute the top few singular values and vectors.
Various truncated-SVD algorithms provide resource-efficient implementations to compute the top k
singular values and vectors instead of the complete-SVD.
3.4.5

Low rank hypothesis.

The factor models that are commonly used in the Econometrics literature, cf. [1, 2, 4], often lead to
a low rank structure for the underlying mean matrix M . When f is nonlinear, M can still be well
approximated by a low rank matrix for a large class of functions. For instance, if the latent parameters
9

assumed values from a bounded, compact set, and if f was Lipschitz continuous, then it can be argued
that M is well approximated by a low rank matrix, cf. see [16] for a very simple proof. As the reader
will notice, while we establish results for low rank matrix, the results of this work are robust to low
rank approximations whereby the approximation error can be viewed as “noise”. Lastly, as shown in
[32], many latent variable models can be well approximated (up to arbitrary accuracy ) by low rank
matrices. Specifically, [32] shows that the corresponding low rank approximation matrices associated
with “nice” functions (e.g. linear functions, polynomials, kernels, etc.) are of log-rank.
3.4.6

Covariate information.

Although the algorithm does not appear to rely on any helpful covariate information and the experimental
results, presented in Section 5, suggest that it performs on par with that of the original synthetic control
algorithm, we want to emphasize that we are not suggesting that practitioners should abandon the use
of any additional covariate information or the application of domain knowledge. Rather, we believe
that our key algorithmic feature – the de-noising step – may render covariates and domain expertise
as luxuries as opposed to necessities for many practical applications. If the practitioner has access to
supplementary predictor variables, we propose that step one of our algorithm be used as a pre-processing
routine for de-noising the data before incorporating additional information. Moreover, other than the
obvious benefit of narrowing the donor pool, domain expertise can also come in handy in various settings,
such as determining the appropriate method for imputing the missing entries in the data. For instance,
if it is known a priori that there is a trend or periodicity in the time series evolution for the units, it may
behoove the practitioner to impute the missing entries using “nearest-neighbors” or linear interpolation.

4

Theoretical Results

In this section, we derive the finite sample and asymptotic properties of the estimators M̂ and M̂1 . We
begin by defining necessary notations and recalling a few operating assumptions prior to presenting
the results, with the corresponding proofs relegated to the Appendix. To that end, we re-write (3) in
matrix form as X = M + E, where E = [it ]2≤i≤N,t∈[T ] denotes the noise matrix. We shall assume that
the noise parameters it are independent zero-mean random variables with bounded second moments.
Specifically, for all 2 ≤ i ≤ N, t ∈ [T ],
E[it ] = 0,

and

Var(it ) ≤ σ 2 .

(17)

We shall also assume that the treatment unit noise in (5) obeys (17). Further, we assume the relationship
in (6) holds. To simplify the following exposition, we assume that |Mij | ≤ 1 and |Xij | ≤ 1.
As previously discussed, we evaluate the accuracy of our estimated means for the treatment unit
with respect to the deviation between M̂1 and M1 measured in `2 -norm, and similarly between M̂
and M . Additionally, we aim to establish the validity of our pre-intervention linear model assumption
(cf. (6)) and investigate how the linear relationship translates over to the post-intervention regime,
i.e. if M1− = (M − )T β ∗ for some β ∗ , does M1+ (approximately) equal to (M + )T β ∗ ? If so, under what
conditions? We present our results for the above aspects after a brief motivation of `2 regularization.
Combatting overfitting. One weapon to combat overfitting is to constrain the learning algorithm to
limit the effective model complexity by fitting the data under a simpler hypothesis. This technique is
known as regularization, and it has been widely used in practice. To employ regularization, we introduce
a complexity penalty term into the objective function (10). For a general regularizer, the objective
function takes the form
β̂(η) = arg min Y1− − (M̂ − )T v
v∈RN −1

2

+η

N
−1
X
j=1

10

q

|vj | ,

(18)

for some choice of positive constants η and q. The first term measures the empirical error of the model
on the given dataset, while the second term penalizes models that are too “complex” by controlling the
“smoothness” of the model in order to avoid overfitting. In general, the impact/trade-off of regularization
can be controlled by the value of the regularization parameter η. Via the use of Lagrange multipliers,
we note that minimizing (18) is equivalent to minimizing (10) subject to the constraint that
N
−1
X

q

|vj | ≤ c,

j=1

for some appropriate value of c. When q = 2, (18) corresponds to the classical setup known as ridge
regression or weight decay. The case of q = 1 is known as the LASSO in the statistics literature; the
`1 -norm regularization of LASSO is a popular heuristic for finding a sparse solution. In either case,
incorporating an additional regularization term encourages the learning algorithm to output a simpler
model with respect to some measure of complexity, which helps the algorithm avoid overfitting to the
idiosyncrasies within the observed dataset. Although the training error may suffer from the simpler
model, empirical studies have demonstrated that the generalization error can be greatly improved under
this new setting. Throughout this section, we will primarily focus our attention on the case of q = 2,
which maintains our learning objective to be (convex) quadratic in the parameter v so that its exact
minimizer can be found in closed form:

−1
β̂(η) = M̂ − (M̂ − )T + ηI
M̂ − Y1− .
(19)

4.1

Imputation analysis.

In this section, we highlight the importance of our de-noising procedure and prescribe a universal
threshold (similar to that of [16]) that dexterously distinguishes signal from noise, enabling the algorithm
to capture the appropriate amount of useful information (encoded in the singular values of Y ) while
discarding out the randomness. Due to its universality, the threshold naturally adapts to the amount of
structure within M in a purely data-driven manner. Specifically, for any choice of ω ∈ (0.1, 1), we find
that choosing
p
µ = (2 + ω) T (σ̂ 2 p̂ + p̂(1 − p̂)),
(20)
results in an estimator with strong theoretical properties for both interpolation and extrapolation
(discussed in Section 4.2). Here, p̂ and σ̂ 2 denote the unbiased maximum likelihood estimates of p and
σ 2 , respectively, and can be computed via (9) and (12).
The following Theorems (adapted from Theorems 2.1 and 2.7 of [16]) demonstrate that Step 1 of
our algorithm (detailed in Section 3.2) accurately imputes missing entries within our data matrix X
when the signal matrix M is either low rank or generated by an L-Lipschitz function. In particular,
Theorems 4.1 and 4.2 states that Step 1 produces a consistent estimator of the underlying mean matrix
M with respect to the (matrix) mean-squared-error, which is defined as
MSE(M̂ ) =

N X
T
hX
i
1
E
(M̂ij − Mij )2 .
(N − 1)T
i=2 j=1

(21)

We say that M̂ is a consistent estimator of M if the right-hand side of (21) converges to zero as N and
T grow without bound.
The following theorem demonstrates that M̂ is a good estimate of M when M is a low rank matrix,
particularly when the rank of M is small compared to (N − 1)p.

11

Theorem 4.1. (Theorem 2.1 of [16]) Suppose that M is rank k. Suppose that p ≥
ζ > 0. Then using µ as defined in (20),
s


k
1
,
+O
MSE(M̂ ) ≤ C1
(N − 1)p
(N − 1)T

T −1+ζ
σ 2 +1

for some

(22)

where C1 is a universal positive constant.
Suppose that the latent row and column feature vectors, {θi } and {ρj }, belong to some bounded,
closed sets K ⊂ Rd , where d is some arbitrary but fixed dimension. If we assume f : K × K → [−1, 1]
possesses desirable smoothness properties such as Lipschitzness, then M̂ is again a good estimate of M .
Theorem 4.2. (Theorem 2.7 of [16]) Suppose f is a L-Lipschitz function. Suppose that p ≥
for some ζ > 0. Then using µ as defined in (20),

T −1+ζ
σ 2 +1

1



(N − 1)− d+2
1
MSE(M̂ ) ≤ C(K, d, L)
,
+O
√
p
(N − 1)T

(23)

where C(K, d, L) is a constant depending on K, d, and L.
It is important to observe that the models under consideration for both Theorems 4.1 and 4.2
encompass the mean matrices, M , generated as per many of the popular Econometric factor models
often considered in literature and assumed in practice. Therefore, de-noising the data serves as an
important imputing and filtering procedure for a wide array of applications.

4.2

Forecasting analysis: pre-intervention regime.

Similar to the setting for interpolation, the prediction performance metric of interest is the average
mean-squared-error in estimating M1− using M̂1− . Precisely, we define
MSE(M̂1− ) =

T0
i
1 hX
E
(M1t − M̂1t )2 .
T0
t=1

(24)

If the right-hand side of (33) approaches zero in the limit as T0 grows without bound, then we say that
M̂1− is a consistent estimator of M1− (note that our analysis here assumes that only T0 → ∞).
In what follows, we first state the finite sample bound on the average MSE between M̂1− and M1− for
the most generic setup (Theorem 4.3). As a main Corollary of the result, we specialize the bound in
the case where we use our prescribed universal threshold. Finally, we discuss a minor variation of the
algorithm where the data is pre-processed, and specialize the above result to establish the consistency of
our estimator (Theorem 4.4).
4.2.1

General result.

We provide a finite sample error bound for the most generic setting, i.e. for any choice of the threshold,
µ, and regularization hyperparameter, η.
Theorem 4.3. For any η ≥ 0 and µ ≥ 0, the pre-intervention error of the algorithm can be bounded as
MSE(M̂1− ) ≤

2 2σ 2 |S| ηkβ ∗ k2
C1  ∗
−
E
λ
+
kY
−
pM
k
+
(p̂
−
p)M
+
+
+ C2 e−cp(N −1)T . (25)
p2 T0
T0
T0

Here, λ1 , . . . , λN −1 are the singular values of pM in decreasing order and repeated by multiplicities, with
λ∗ = maxi∈S
/ λi ; C1 , C2 and c are universal positive constants.
12

Bias-variance tradeoff. Let us interpret the result by parsing the terms in the error bound. The
last term decays exponentially with (N − 1)T , as long as the fraction of observed entries is such that, on
average, we see a super-constant number of entries, i.e. p(N − 1)T  1. More interestingly, the first two
terms highlight the “bias-variance tradeoff” of the algorithm with respect to the singular value threshold
µ. Precisely, the size of the set S increases with a decreasing value of the hyperparameter µ, causing the
second error term to increase. Simultaneously, however, this leads to a decrease in λ∗ . Note that λ∗
denotes the aspect of the “signal” within the matrix M that is not captured due to the thresholding
through S. On the other hand, the second term, |S|σ 2 /T0 , represents the amount of “noise” captured by
the algorithm, but wrongfully interpreted as a signal, during the thresholding process. In other words, if
we use a large threshold, then our model may fail to capture pertinent information encoded in M ; if
we use a small threshold, then the algorithm may overfit the spurious patterns in the data. Thus, the
hyperparameter µ provides a way to trade-off “bias” (first term) and “variance” (second term).
4.2.2

Goldilocks principle: a universal threshold.

Using the universal threshold defined in (20), we now highlight the prediction power of our estimator for
any choice of η, the regularization hyperparameter. As described in Section 4.1, the prescribed threshold
automatically captures the “correct” level of information encoded in the (noisy) singular values of Y in
a data-driven manner, dependent on the structure of M . However, unlike the statements in Theorems
4.1 and 4.2, the following bound does not require M to be low rank or f to be Lipschitz.
−1+ζ

Corollary 4.1. Suppose p ≥ Tσ2 +1 for some ζ > 0. Let T ≤ αT0 for some constant α > 1. Then for
any η ≥ 0 and using µ as defined in (20), the pre-intervention error is bounded above by
MSE(M̂1− ) ≤

p
C1 2
(σ + (1 − p)) + O(1/ T0 ),
p

(26)

where C1 is a universal positive constant.
√
√
√
As an implication, if p = (1 + ϑ) T0 /(1 + T0 ) and σ 2 ≤ ϑ, we have that MSE(M̂1− ) = O(1/ T0 ).
More generally, Corollary 4.1 shows that by adroitly capturing the signal, the resulting error bound
simply depends on the variance of the noise terms, σ 2 , and the error introduced due to missing data.
Ideally, one would hope to overcome the error term when T0 is sufficiently large. This motivates the
following setup.
4.2.3

Consistency.

We present a straightforward pre-processing step that leads to the consistency of our algorithm. The
pre-processing step simply involves replacing the columns of X by the averages of subsets of its columns.
This admits the same setup as before, but with the variance for each noise term reduced. An implicit
side benefit of this approach is that required SVD step in the algorithm is now applied to a matrix of
smaller dimensions.
To begin, partition the T0 columns of the pre-intervention data matrix X − into ∆ blocks, each of size
τ = bT0 /∆c except potentially the last block, which we shall ignore for theoretical purposes; in practice,
however, the remaining columns can be placed into the last block. Let Bj = {(j − 1)τ + ` : 1 ≤ ` ≤ τ }
denote the column indices of X − within partition j ∈ [∆]. Next, we replace the τ columns within
each partition by their average, and thus create a new matrix, X̄ − , with ∆ columns and N − 1 rows.
Precisely, X̄ − = [X̄ij ]2≤i≤N,j∈[∆] with
X̄ij =

1 X
Xit · Dit ,
τ
t∈Bj

13

(27)

where
(
Dit =
For the treatment row, let X̄1j =

p̂
τ

1 if Xit is observed,
0 otherwise.

X1t for all j ∈ [∆]2 . Let M̄ − = [M̄ij ]2≤i≤N,j∈[∆] with
p X
Mit .
(28)
M̄ij = E[X̄ij ] =
τ

P

t∈Bj

t∈Bj

ˆ − of M̄ − , which is sufficient to produce β̂(η).
We apply the algorithm to X̄ − to produce the estimate M̄
This β̂(η) can be used to produce the post-intervention synthetic control means M̂1+ = [M̂1t ]T0 <t≤T in a
similar manner as before 3 : for T0 < t ≤ T ,
M̂1t =

N
X

β̂i (η)Xit .

(29)

i=2

ˆ − = [M̄
ˆ ]
For the pre-intervention period, we produce the estimator M̄
1j j∈[∆] : for j ∈ [∆],
1
ˆ =
M̄
1j

N
X

ˆ .
β̂i (η)M̄
ij

(30)

i=2

Our measure of estimation error is defined as
∆
hX
i
ˆ )2 .
ˆ −) = 1 E
(M̄1j − M̄
MSE(M̄
1j
1
∆ j=1

(31)

For simplicity, we will analyze the case where each block contains at least one entry such that X̄ − is
completely observed. We now state the following result.
q
1
+γ
Theorem 4.4. Fix any γ ∈ (0, 1/2) and ω ∈ (0.1, 1). Let ∆ = T02
and µ = (2+ω) T02γ (σ̂ 2 p̂ + p̂(1 − p̂)).
Suppose p ≥

T0−2γ
σ 2 +1

is known. Then for any η ≥ 0,
ˆ − ) = O(T −1/2+γ ).
MSE(M̄
1
0

(32)

We note that the method of [4, Sec 2.3] learns the weights (here β̂(0)) by pre-processing the data. One
common pre-processing proposal is to also aggregate the columns, but the aggregation parameters are
chosen by solving an optimization problem to minimize the resulting prediction error of the observations.
In that sense, the above averaging of column is a simple, data agnostic approach to achieve a similar
effect, and potentially more effectively.

4.3

Forecasting analysis: post-intervention regime.

For the post-intervention regime, we consider the average root-mean-squared-error in measuring the
performance of our algorithm. Precisely, we define
RMSE(M̂1+ ) = √

T
h X
1/2 i
1
E
(M1t − M̂1t )2
.
T − T0
t>T

(33)

0

2 Although the statement in Theorem 4.4 assumes that an oracle provides the true p, we prescribe practitioners to use p̂
since p̂ converges to p almost surely by the Strong Law of Large Numbers.
3 In practice, one can first de-noise X + via step one of Section 3, and use the entries of M̂ + in (29).

14

The key assumption of our analysis is that the treatment unit signal can be written as a linear combination of donor pool signals. Specifically, we assume that this relationship holds in the pre-intervention
regime, i.e. M1− = (M − )T β ∗ for some β ∗ ∈ RN −1 as stated in (6). However, the question still remains:
does the same relationship hold for the post-intervention regime and if so, under what conditions does it
hold? We state a simple linear algebraic fact to this effect, justifying the approach of synthetic control.
It is worth noting that this important aspect has been amiss in the literature, potentially implicitly
believed or assumed starting in the work by [4].
Theorem 4.5. Let (6) hold for some β ∗ . Let rank(M − ) = rank(M ). Then M1+ = (M + )T β ∗ .
If we assume that the linear relationship prevails in the post-intervention period, then we arrive at
the following error bound.
Theorem 4.6. Suppose p ≥

T −1+ζ
σ 2 +1

0

for some ζ > 0. Suppose β̂(η)
0

∞

≤ ψ for some ψ > 0. Let

α T0 ≤ T ≤ αT0 for some constants α , α > 1. Then for any η ≥ 0 and using µ as defined in (20), the
post-intervention error is bounded above by
p
C1
C2 kM k
RMSE(M̂1+ ) ≤ √ (σ 2 + (1 − p))1/2 + √
· E β̂(η) − β ∗ + O(1/ T0 ),
p
T0
where C1 and C2 are universal positive constants.
Benefits of regularization. In order to motivate the use of regularization, we analyze the error
bounds of Theorems 4.3 and 4.6 to observe how the pre- and post-intervention errors react to regularization.
As seen from Theorem 4.3, the pre-intervention error increases linearly with respect to the choice of
η. Intuitively, this increase in pre-intervention error derives from the fact that regularization reduces
the model complexity, which biases the model and handicaps its ability to fit the data. At the same
time, by restricting the hypothesis space and controlling the “smoothness” of the model, regularization
prevents the model from overfitting to the data, which better equips the model to generalize to unseen
data. Therefore, a larger value of η reduces the post-intervention error. This can be seen by observing
the second error term of Theorem 4.6, which is controlled by the expression β̂(η) − β ∗ . In words, this
error is a function of the learning algorithm used to estimate β ∗ . Interestingly, [18] demonstrates that
there exists an η > 0 such that
β̂(η) − β ∗ ≤ β̂(0) − β ∗ ,
without any assumptions on the rank of M̂ − . In other words, [18] demonstrates that regularization can
decrease the MSE between β̂(η) and the true β ∗ , thus reducing the overall error. Ultimately, employing
ridge regression introduces extraneous bias into our model, yielding a higher pre-intervention error. In
exchange, regularization reduces the post-intervention error (due to smaller variance).

4.4

Bayesian analysis.

We turn our attention to a Bayesian treatment of synthetic control. By operating under a Bayesian
framework, we allow practitioners to naturally encode domain knowledge into prior distributions while
simultaneously avoiding the problem of overfitting. In addition, rather than making point estimates, we
can now quantitatively express the uncertainty in our estimates with posterior probability distributions.
We begin by treating β ∗ as a random variable as opposed to an unknown constant. In this approach,
we specify a prior distribution, p(β), that expresses our apriori beliefs and preferences about the
underlying parameter (synthetic control). Given some new observation for the donor units, our goal is to
make predictions for the counterfactual treatment unit on the basis of a set of pre-intervention (training)

15

data. For the moment, let us assume that the noise parameter σ 2 is a known quantity and that the
noise is drawn from a Gaussian distribution with zero-mean; similarly, we temporarily assume M − is
also given. Let us denote the vector of donor estimates as M·t = [Mit ]2≤i≤N ; we define X·t similarly.
Denoting the pre-intervention data as D = {(Y1t , M·t ) : t ∈ [T0 ]}, the likelihood function p(Y1− | β, M − )
is expressed as
p(Y1− | β, M̂ − ) = N ((M − )T β, σ 2 I),

(34)

an exponential of a quadratic function of β. The corresponding conjugate prior, p(β), is therefore given
by a Gaussian distribution, i.e. β ∼ N (β | β0 , Σ0 ) with mean β0 and covariance Σ0 . By using a conjugate
Gaussian prior, the posterior distribution, which is proportional to the product of the likelihood and the
prior, will also be Gaussian. Applying Bayes’ Theorem (derivation unveiled in the Appendix), we have
that the posterior distribution is p(β | D) = N (βD , ΣD ) where
−1

1
−
− T
(35)
ΣD = Σ−1
0 + 2 M (M )
σ
!
1
β D = ΣD
M − Y1− + Σ−1
(36)
0 β0 .
σ2
For the remainder of this section, we shall consider a popular form of the Gaussian prior. In particular,
we consider a zero-mean isotropic Gaussian with the following parameters: β0 = 0 and Σ0 = α−1 I for
some choice of α > 0. Since M − is unobserved by the algorithm, we use the estimated M̂ − , computed
as per step one of Section 3, as a proxy; therefore, we redefine our data as D = {(Y1t , M̂·t ) : t ∈ [T0 ]}.
Putting everything together, we have that p(β | D) = N (βD , ΣD ) whereby

−1
1
ΣD = αI + 2 M̂ − (M̂ − )T
(37)
σ
1
βD = 2 ΣD M̂ − Y1−
(38)
σ
!−1
1
1
−
− T
M̂ − Y1− .
(39)
M̂ (M̂ ) + αI
= 2
σ
σ2
4.4.1

Maximum a posteriori (MAP) estimation.

By using the zero-mean, isotropic Gaussian conjugate prior, we can derive a point estimate of β ∗ by
maximizing the log posterior distribution, which we will show is equivalent to minimizing the regularized
objective function of (10) for a particular choice of η. In essence, we are determining the optimal β̂ by
finding the most probable value of β ∗ given the data and under the influence of our prior beliefs. The
resulting estimate is known as the maximum a posteriori (MAP) estimate.
We begin by taking the log of the posterior distribution, which gives the form
ln p(β | D) = −

1
Y − − (M̂ − )T β
2σ 2 1

2

−

α
2
kβk + const.
2

Maximizing the above log posterior then equates to minimizing the quadratic regularized error (10) with
η = ασ 2 . We define the MAP estimate, β̂MAP , as
β̂MAP = arg max ln p(β | D)
β∈RN −1
2
1 −
ασ 2
2
Y1 − (M̂ − )T β +
kβk
2
β∈RN −1 2

−1
= M̂ − (M̂ − )T + ασ 2 I
M̂ − Y1− .

= arg min

16

(40)

With the MAP estimate at hand, we then make predictions of the counterfactual as
M̂1 = M̂ T β̂MAP .

(41)

Therefore, we have seen that the MAP estimation is equivalent to ridge regression since the introduction
of an appropriate prior naturally induces the additional complexity penalty term.
4.4.2

Fully Bayesian treatment.

Although we have treated β ∗ as a random variable attached with a prior distribution, we can venture
beyond point estimates to be fully Bayesian. In particular, we will make use of the posterior distribution
over β ∗ to marginalize over all possible values of β ∗ in evaluating the predictive distribution over Y1− .
We will decompose the regression problem of predicting the counterfactual into two separate stages: the
inference stage in which we use the pre-intervention data to learn the predictive distribution (defined
shortly), and the subsequent decision stage in which we use the predictive distribution to make estimates.
By separating the inference and decision stages, we can readily develop new estimators for different
loss functions without having to relearn the predictive distribution, providing practitioners tremendous
flexibility with respect to decision making.
Let us begin with a study of the inference stage. We evaluate the predictive distribution over Y1t ,
which is defined as
Z
p(Y1t | M̂·t , D) = p(Y1t | M̂·t , β) p(β | D) dβ
2
= N (M̂·tT βD , σD
),

(42)

where
2
T
σD
= σ 2 + M̂·,t
ΣD M̂·,t .

(43)

Note that p(β | D) is the posterior distribution over the synthetic control parameter and is governed by
(37) and (39). With access to the predictive distribution, we move on towards the decision stage, which
consists of determining a particular estimate M̂1t given a new observation vector X·t (used to determine
M̂·t ). Consider an arbitrary loss function L(Y1t , g(M̂·t )) for some function g. The expected loss is then
given by
Z Z
E[L] =
L(Y1t , g(M̂·t )) · p(Y1t , M̂·t ) dY1t dM̂·t
!
Z
Z
=

L(Y1t , g(M̂·t )) · p(Y1t | M̂·t ) dY1t p(M̂·t ) dM̂·t ,

(44)

and we choose our estimator ĝ(·) as the function that minimizes the average cost, i.e.,
ĝ(·) = arg min E[L(Y1t , g(M̂·t ))].

(45)

g(·)

Since p(M̂·t ) ≥ 0, we can minimize (44) by selecting ĝ(M̂·t ) to minimize the term within the parenthesis
for each individual value of Y1t , i.e.,
M̂1t = ĝ(M̂·t )
Z
= arg min

L(Y1t , g(M̂·t )) · p(Y1t | M̂·t ) dY1t .

(46)

g(·)

As suggested by (46), the optimal estimate M̂1t for a particular loss function depends on the model only
through the predictive distribution p(Y1t | M̂·t , D). Therefore, the predictive distribution summarizes all
of the necessary information to construct the desired Bayesian estimator for any given loss function L.
17

4.4.3

Bayesian least-squares estimate.

We analyze the case for the squared loss function (MSE), a common cost criterion for regression problems.
In this case, we write the expected loss as
!
Z
Z
E[L] =

(Y1t − g(M̂·t ))2 · p(Y1t | M̂·t ) dY1t p(M̂·t ) dM̂·t .

Under the MSE cost criterion, the optimal estimate is the mean of the predictive distribution, also
known as the Bayes’ least-squares (BLS) estimate:
M̂1t = E[Y1t | M̂·t , D]
Z
= Y1t p(Y1t | M̂·t , D)dY1t
= M̂·tT βD .

(47)

Remark 4.6.1. Since the noise variance σ 2 is usually unknown in practice, we can introduce another
conjugate prior distribution p(β, 1/σ 2 ) given by the Gaussian-gamma distribution. This prior yields a
Student’s t-distribution for the predictive probability distribution. Alternatively, one can estimate σ 2
via (12).

5

Experiments

We begin by exploring two real-world case studies discussed in [1, 2, 4] that demonstrate the ability
of the original synthetic control’s algorithm to produce a reliable counterfactual reality. We use the
same case-studies to showcase the “robustness” property of our proposed algorithm. Specifically, we
demonstrate that our algorithm reproduces similar results even in presence of missing data, and without
knowledge of the extra covariates utilized by prior works. We find that our approach, surprisingly,
also discovers a few subtle effects that seem to have been overlooked in prior studies. In the following
empirical studies, we will employ three different learning procedures as described in the robust synthetic
control algorithm: (1) linear regression (η = 0), (2) ridge regression (η > 0), and (3) LASSO (ζ > 0).
As described in [1, 2, 3], the synthetic control method allows a practitioner to evaluate the reliability
of his or her case study results by running placebo tests. One such placebo test is to apply the synthetic
control method to a donor unit. Since the control units within the donor pool are assumed to be
unaffected by the intervention of interest (or at least much less affected in comparison), one would
expect that the estimated effects of intervention for the placebo unit should be less drastic and divergent
compared to that of the treated unit. Ideally, the counterfactuals for the placebo units would show
negligible effects of intervention. Similarly, one can also perform exact inferential techniques that are
similar to permutation tests. This can be done by applying the synthetic control method to every
control unit within the donor pool and analyzing the gaps for every simulation, and thus providing a
distribution of estimated gaps. In that spirit, we present the resulting placebo tests (for only the case
of linear regression) for the Basque Country and California Prop. 99 case studies below to assess the
significance of our estimates.
We will also analyze both case studies under a Bayesian setting. From our results, we see that our
predictive uncertainty, captured by the standard deviation of the predictive distribution, is influenced
by the number of singular values used in the de-noising process. Therefore, we have plotted the
eigenspectrum of the two case study datasets below. Clearly, the bulk of the signal contained within the
datasets is encoded into the top few singular values – in particular, the top two singular values. Given
that the validation errors computed via forward chaining are nearly identical for low-rank settings (with
the exception of a rank-1 approximation), we shall use a rank-2 approximation of the data matrix. In
18

order to exhibit the role of thresholding in the interplay between bias and variance, we also plot the
cases where we use threshold values that are too high (bias) or too low (variance). For each figure, the
dotted blue line will represent our posterior predictive means while the shaded light blue region spans
one standard deviation on both sides of the mean. As we shall see, our predictive uncertainty is smallest
in the neighborhood around the pre-intervention period. However, the level of uncertainty increases as
we deviate from the the intervention point, which appeals to our intuition.
In order to choose an appropriate choice of the prior parameter α, we first use forward-chaining
for the ridge regression setting to find the optimal regularization hyperparameter η. By observing the
expressions of (19) and (40), we see that η = ασ 2 since ridge regression is closely related to MAP
estimation for a zero-mean, isotropic Gaussian prior. Consequently, we choose α = η/σ̂ 2 where η is the
value obtained via forward chaining.

(a) Eigenspectrum of Basque data.

5.1

(b) Eigenspectrum of California data.

Basque Country

The goal of this case-study is to investigate the effects of terrorism on the economy of Basque Country
using the neighboring Spanish regions as the control group. In 1968, the first Basque Country victim of
terrorism was claimed; however, it was not until the mid-1970s did the terrorist activity become more
rampant [4]. To study the economic ramifications of terrorism on Basque Country, we only use as data
the per-capita GDP (outcome variable) of 17 Spanish regions from 1955-1997. We note that in [4], 13
additional predictor variables for each region were used including demographic information pertaining to
one’s educational status, and average shares for six industrial sectors.
Results. Figure 2a shows that our method (for all three estimators) produces a very similar
qualitative synthetic control to the original method even though we do not utilize additional predictor
variables. Specifically, the synthetic control resembles the observed GDP in the pre-treatment period
between 1955-1970. However, due to the large-scale terrorist activity in the mid-70s, there is a noticeable
economic divergence between the synthetic and observed trajectories beginning around 1975. This
deviation suggests that terrorist activity negatively impacted the economic growth of Basque Country.
One subtle difference between our synthetic control – for the case of linear and ridge regression – and
that of [4] is between 1970-75: our approach suggests that there was a small, but noticeable economic
impact starting just prior to 1970, potentially due to first terrorist attack in 1968. Notice, however, that
the original synthetic control of [4] diverges only after 1975. Our LASSO estimator’s trajectory also
agrees with that of the original synthetic control method’s, which is intuitive since both estimators seek
sparse solutions.
To study the robustness of our approach with respect to missing entries, we discard each data point
uniformly at random with probability 1 − p. The resulting control for different values of p is presented in
19

Figure 2b suggesting the robustness of our (linear) algorithm. Finally, we produce Figure 2c by applying
our algorithm without the de-noising step. As evident from the Figure, the resulting predictions suffer
drastically, reinforcing the value of de-noising. Intuitively, using an appropriate threshold µ equates to
selecting the correct model complexity, which helps safeguard the algorithm from potentially overfitting
to the training data.

(a) Comparison of methods.

(b) Missing data.

(c) Impact of de-noising.

Figure 2: Trends in per-capita GDP between Basque Country vs. synthetic Basque Country.

Placebo tests. We begin by applying our robust algorithm to the Spanish region of Cataluna,
a control unit that is not only similar to Basque Country, but also exposed to a much lower level of
terrorism [2]. Observing both the synthetic and observed economic evolutions of Cataluna in Figure
3a, we see that there is no identifiable treatment effect, especially compared to the divergence between
the synthetic and observed Basque trajectories. We provide the results for the regions of Aragon and
Castilla Y Leon in Figures 3b and 3c.

(a) Cataluna.

(b) Aragon.

(c) Castilla Y Leon.

Figure 3: Trends in per-capita GDP for placebo regions.

Finally, similar to [2], we plot the differences between our estimates and the observations for Basque
Country and all other regionals, individually, as placebos. Note that [2] excluded five regions that had
a poor pre-intervention fit but we keep all regions. Figure 4a shows the resulting plot for all regions
with the solid black line being Basque Country. This plot helps visualize the extreme post-intervention
divergence between the predicted means and the observed values for Basque. Up until about 1990, the
divergence for Basque Country is the most extreme compared to all other regions (placebo studies)
lending credence to the belief that the effects of terrorism on Basque Country were indeed significant.
Refer to Figure 4b for the same test but with Madrid and Balearic Islands excluded, as per [2]. The
conclusions drawn should remain the same, pointing to the robustness of our approach.

20

(a) Includes all control regions.

(b) Excludes 2 regions.

Figure 4: Per-capita GDP gaps for Basque Country and control regions.

Bayesian approach. We plot the resulting Bayesian estimates in the figures below under varying
thresholding conditions. It is interesting to note that our uncertainty grows dramatically once we include
more than two singular values in the thresholding process. This confirms what our theoretical results
indicated earlier: choosing a smaller threshold, µ, would lead to a greater number of singular values
retained which results in higher variance. On the other hand, notice that just selecting 1 singular value
results in an apparently biased estimate which is overestimating the synthetic control. It appears that
selecting the top two singular values balance the bias-variance tradeoff the best and is also agrees with
our earlier finding that the data matrix appears to be of rank 2 or 3. Note that in this setting, we would
find it hard to reject the null-hypothesis because the observations for the treated unit lie within the
uncertainty band of the estimated synthetic control.

(a) Top singular value.

(b) Top two singular values.

(c) Top three singular values.

(d) Top four values.

(e) Top five singular values.

(f ) Top six singular values.

Figure 5: Trends in per-capita GDP between Basque Country vs. synthetic Basque Country.

21

5.2

California Anti-tobacco Legislation

We study the impact of California’s anti-tobacco legislation, Proposition 99, on the per-capita cigarette
consumption of California. In 1988, California introduced the first modern-time large-scale anti-tobacco
legislation in the United States [1]. To analyze the effect of California’s anti-tobacco legislation, we use
the annual per-capita cigarette consumption at the state-level for all 50 states in the United States,
as well as the District of Columbia, from 1970-2015. Similar to the previous case study, [4] uses 6
additional observable covariates per state, e.g. retail price, beer consumption per capita, and percentage
of individuals between ages of 15-24, to predict their synthetic California. Furthermore, [4] discarded 12
states from the donor pool since some of these states also adopted anti-tobacco legislation programs or
raised their state cigarette taxes, and discarded data after the year 2000 since many of the control units
had implemented anti-tobacco measures by this point in time.
Results. As shown in Figure 6a, in the pre-intervention period of 1970-88, our control matches the
observed trajectory. Post 1988, however, there is a significant divergence suggesting that the passage of
Prop. 99 helped reduce cigarette consumption. Similar to the Basque case-study, our estimated effect is
similar to that of [4]. As seen in Figure 6b, our algorithm is again robust to randomly missing data.

(a) Comparison of methods.

(b) Missing data.

Figure 6: Trends in per-capita cigarette sales between California vs. synthetic California.

Placebo tests. We now proceed to apply the same placebo tests to the California Prop 99 dataset.
Figures 7a, 7b, and 7c are three examples of the applied placebo tests on the remaining states (including
District of Columbia) within the United States.

(a) Colorado.

(b) Iowa.

(c) Wyoming.

Figure 7: Placebo Study: trends in per-capita cigarette sales for Colorado, Iowa, and Wyoming.

Finally, similar to [1], we plot the differences between our estimates and the actual observations for
California and all other states, individually, as placebos. Note that [1] excluded twelve states but we
keep all states. Figure 8a shows the resulting plot for all states with the solid black line being California.
22

This plot helps visualize the extreme post-intervention divergence between the predicted means and the
observed values for California. Up until about 1995, the divergence for California was clearly the most
significant and consistent outlier compared to all other regions (placebo studies) lending credence to the
belief that the effects of Proposition 99 were indeed significant. Refer to Figure 8b for the same test but
with the same twelve states excludes as in [1]. Just like the Basque Country case study, the exclusion of
states should not affect the conclusions drawn.

(a) Includes all donors.

(b) Excludes 12 states.

Figure 8: Per-capita cigarette sales gaps in California and control regions.

Bayesian approach. Similar to the Basque Country case study, our predictive uncertainty increases
as the number of singular values used in the learning process exceeds two. In order to gain some
new insight, however, we will focus our attention to the resulting figure associated with three singular
values, which is particularly interesting. Specifically, we observe that our predictive means closely match
the counterfactual trajectory produced by the classical synthetic control method in both the pre- and
post-intervention periods (up to year 2000), and yet our uncertainty for this estimate is significantly
greater than our uncertainty associated with the estimate produced using two singular values. As a
result, it may be possible that the classical synthetic control method overestimated the effect of Prop.
99, even though the legislation did probably discourage the consumption of cigarettes – a conclusion
reached by both our robust approach and the classical approach.

(a) Top singular value.

(b) Top two singular values.

(c) Top three singular values.

Figure 9: Trends in per-capita cigarette sales between California vs. synthetic California.

Remark 5.0.1. We note that in [3], the authors ran two robustness tests to examine the sensitivity of
their results (produced via the original synthetic control method) to alterations in the estimated convex
weights – recall that the original synthetic control estimator produces a β ∗ that lies within the simplex.
In particular, the authors first iteratively reproduced a new synthetic West Germany by removing one
of the countries that received a positive weight in each iteration, demonstrating that their synthetic
model is fairly robust to the exclusion of any particular country with positive weight. Furthermore, [3]
examined the trade-off between the original method’s ability to produce a good estimate and the sparsity
23

of the given donor pool. In order to examine this tension, the authors restricted their synthetic West
Germany to be a convex combination of only four, three, two, and a single control country, respectively,
and found that, relative to the baseline synthetic West Germany (composed of five countries), the
degradation in their goodness of fit was moderate.

5.3

Synthetic simulations

We conduct synthetic simulations to establish the various properties of the estimates in both the preand post-intervention stages.
Experimental setup. For each unit i ∈ [N ], we assign latent feature θi by drawing a number
uniformly at random in [0, 1]. For each time t ∈ [T ], we assign latent variable ρt = t. The mean value
mit = f (θi , ρt ). In the experiments described in this section, we use the following:
f (θi , ρt ) =θi + (0.3 · θi · ρt /T ) ∗ (expρt /T )+
cos(f1 π/180) + 0.5 sin(f2 π/180) + 1.5 cos(f3 π/180) − 0.5sin(f4 ∗ π/180)

where f1 , f2 , f3 , f4 define the periodicities: f1 = ρt mod (360), f2 = ρt mod (180), f3 = 2 · ρt mod
(360), f4 = 2.0 · ρt mod (180). The observed value Xit is produced by adding i.i.d. Gaussian noise to
mean with zero mean and variance σ 2 . For this set of experiments, we use N = 100, T = 2000, while
assuming the treatment was performed at t = 1600.

Figure 10: Treatment unit: noisy observations (gray) and true means (blue) and the estimates from our
algorithm (red) and one where no singular value thresholding is performed (green). The plots show all entries
normalized to lie in range [−1, 1]. Notice that the estimates in red generated by our model are much better at
estimating the true underlying mean (blue) when compared to an algorithm which performs no singular value
thresholding.

24

Figure 11: Same dataset as shown in Figure 10 but with 40% data missing at random. Treatment unit: not
showing the noisy observations for clarity; plotting true means (blue) and the estimates from our algorithm (red)
and one where no singular value thresholding is performed (green). The plots show all entries normalized to lie
in range [−1, 1].

Training error approximates generalization error. For the first experimental study, we analyze
the relationship between the pre-intervention MSE (training error) and the post-intervention MSE
(generalization error). As seen in Table 1, the post-intervention MSE closely matches that of the
pre-intervention MSE for varying noise levels, σ 2 . Thus suggesting efficacy of our algorithm. Figures
10 and 11 plot the estimates of algorithm with no missing data (Figure 10) and with 40% randomly
missing data (Figure 11) on the same underlying dataset. All entries in the plots were normalized to lie
within [−1, 1]. These plots confirm the robustness of our algorithm. Our algorithm outperforms the
algorithm with no singular value thresholding under all proportions of missing data. The estimates from
the algorithm which performs no singular value thresholding (green) degrade significantly with missing
data while our algorithm remains robust.
Table 1: Training vs. generalization error

Noise

Training error

Generalization error

3.1
2.5
1.9
1.3
0.7
0.4
0.1

0.48
0.31
0.19
0.09
0.027
0.008
0.0005

0.53
0.34
0.22
0.1
0.03
0.009
0.0006

Benefits of de-noising. We now analyze the benefit of de-noising the data matrix, which is the
main contribution of this work compared to the prior work. Specifically, we study the generalization
error of method using de-noising via thresholding and without thresholding as in prior work. The results
summarized in Table 2 show that for range of parameters the generalization error with de-noising is
consistency better than that without de-noising.

25

Table 2: Impact of thresholding

Noise

De-noising error

No De-noising error

3.1
2.5
1.9
1.6
1
0.7
0.4

0.122
0.079
0.046
0.032
0.013
0.006
0.002

0.365
0.238
0.138
0.098
0.038
0.018
0.005

Bayesian approach. From the synthetic simulations (figures below), we see that the number
of singular values included in the thresholding process plays a crucial role in the model’s prediction
capabilities. If not enough singular values are used, then there is a significant loss of information (high
bias) resulting in a higher MSE. On the other hand, if we include too many singular values, then the
model begins to overfit to the dataset by misinterpreting noise for signal (high variance). As emphasized
before, the goal is to find the simplest model that both fits the data and is also plausible, which is
achieved when four singular values are employed.

6

(a) Top singular value.

(b) Top two singular values.

(c) Top four singular values.

(d) Top five singular values.

(e) Top 10 singular values.

(f ) Top 16 singular values.

Conclusion

The classical synthetic control method is recognized as a powerful and effective technique for causal
inference for comparative case studies. In this work, we motivate a robust synthetic control algorithm,
which attempts to improve on the classical method in the following regimes: (a) randomly missing
data and (b) large levels of noise. We also demonstrate that the algorithm performs well even in the
absence of covariate or expert information, but do not propose ignoring information which may eliminate
“bad” donors. Our data-driven algorithm, and its Bayesian counterpart, uses singular value thresholding

26

to impute missing data and “de-noise” the observations. Once “de-noised”, we use regularized linear
regression to determine the synthetic control. Motivating our algorithm is a modeling framework,
specifically the Latent Variable Model, which is a generalization of the various factor models used in
related work. We establish finite-sample bounds on the MSE between the estimated “synthetic” control
and the latent true means of the treated unit of interest. In situations with plentiful data, we show that
a simple data aggregation method can lead to an asymptotically consistent estimator. Experiments
on synthetically generated data (where the truth is known) and on real-world case-studies allow us to
demonstrate the promise of our approach, which is an improvement over the classical method.

27

References
[1] A. Abadie, A. Diamond, and J. Hainmueller. Synthetic control methods for comparative case
studies: Estimating the effect of californiaâs tobacco control program. Journal of the American
Statistical Association, 2010.
[2] A. Abadie, A. Diamond, and J. Hainmueller. Synth: An r package for synthetic control methods in
comparative case studies. Journal of Statistical Software, 2011.
[3] A. Abadie, A. Diamond, and J. Hainmueller. Comparative politics and the synthetic control method.
American Journal of Political Science, 2014.
[4] A. Abadie and J. Gardeazabal. The economic costs of conflict: A case study of the basque country.
American Economic Review, 2003.
[5] B. Adhikari and J. Alm. Evaluating the economic effects of flat tax reforms using synthetic control
methods. Southern Economic Association, 2016.
[6] D. J. Aldous. Representations for partially exchangeable arrays of random variables. Journal of
Multivariate Analysis, 11(4):581–598, 1981.
[7] S. Athey, M. Bayati, N. Doudchenko, and G. Imbens. Matrix completion methods for causal panel
data models. 2017.
[8] S. Athey and G. Imbens. The state of applied econometrics - causality and policy evaluation. The
Journal of Economic Perspectives, 31(2):3–32, 2016.
[9] H. Aytug, M. Kutuk, A. Oduncu, and S. Togan. Twenty years of the eu-turkey customs union: A
synthetic control method analysis. Journal of Common Market Studies, 2016.
[10] BallotPedia. California proposition 63, background checks for ammunition purchases and largecapacity ammunition magazine ban (2016). www.ballotpedia.org, 2016.
[11] A. Billmeier and T. Nannicini. Assessing economic liberalization episodes: A synthetic control
approach. The Review of Economics and Statistics, 2013.
[12] C. Bishop. Pattern Recognition and Machine Learning. Springer, 2006.
[13] C. Borgs, J. Chayes, C. E. Lee, and D. Shah. Thy friend is my friend: Iterative collaborative
filtering for sparse matrix estimation. Advances in Neural Information Processing Systems, 2017.
[14] K. Brodersen, F. Gallusser, J. Koehler, N. Remy, and S. Scott. Inferring causal impact using
bayesian structural time-series models. Annals of Applied Statistics, 2015.
[15] E. J. Candès and B. Recht. Exact matrix completion via convex optimization. CoRR, abs/0805.4471,
2008.
[16] S. Chatterjee. Matrix estimation by universal singular value thresholding. Annals of Statistics,
43:177–214, 2015.
[17] N. Doudchenko and G. Imbens. Balancing, regression, difference-in-differences and synthetic control
methods: A synthesis. NBER Working Paper No. 22791, 2016.
[18] R. Farebrother. Further results on the mean square error of ridge regression. Journal of the Royal
Statistical Society. Series B (Methodological), 38(3):248–250, 1976.
[19] B. Ferman and C. Pinto. Revisiting the synthetic control estimator. 2016.
[20] B. Ferman, C. Pinto, and V. Possebom. Cherry picking with synthetic controls. 2016.

28

[21] J. Gardeazabal and A. Vega-Bayo. An empirical comparison between the synthetic control method
and hsiao et al.’s panel data approach to program evaluation. Journal of Applied Econometrics,
2016.
[22] D. N. Hoover. Relations on probability spaces and arrays of random variables. 1979.
[23] D. N. Hoover. Row-columns exchangeability and a generalized model for exchangeability. Exchangeability in probability and statistics, (281-291), 1981.
[24] C. Hsiao. Analysis of panel data. Cambridge University Press, 2014.
[25] C. Hsiao, H. Ching, and S. Wan. A panel data approach for program evaluation: Measuring the
benefits of political and economic integration of hong kong with mainland china. Journal of Applied
Econometrics, 2011.
[26] Jha, S. K., and R. D. S. Yadava. Denoising by singular value decomposition and its application to
electronic nose data processing. IEEE Sensors Journal, 11:35–44, June 2010.
[27] N. Kreif, R. Grieve, D. Hangartner, A. Turner, S. Nikolova, and M. Sutton. Examination of
the synthetic control method for evaluating health policies with multiple treated units. Health
Economics, 2015.
[28] C. E. Lee, Y. Li, D. Shah, and D. Song. Blind regression via nearest neighbors under latent variable
models. Advances in Neural Information Processing Systems, 2016.
[29] R. Mazumder, T. Hastie, and R. Tibshirani. Spectral regularization algorithms for learning large
incomplete matrices. Journal of machine learning research, 11(Aug):2287–2322, 2010.
[30] P. McGreevy. California voters approve gun control measure proposition 63. Los Angeles Times,
Nov. 2016.
[31] J. Saunders, R. Lundberg, A. Braga, G. Ridgeway, and J. Miles. A synthetic control approach to
evaluating place-based crime interventions. Journal of Quantitative Criminology, 2014.
[32] M. Udell and A. Townsend. Nice latent variable models have log-rank. 2017.
[33] P. J. Wolfe and S. C. Olhede. Nonparametric graphon estimation. https://arxiv.org/abs/1309.5936.
[34] Y. Xu. Generalized synthetic control method: Causal inference with interactive fixed effects models.
Political Analysis, 25(1), 2017.
[35] J. Yang, Q. Han, and E. M. Airoldi. Nonparametric estimation and testing of exchangeable
graph models. Journal of Machine Learning Research, Conference and Workshop Proceedings,
33:1060–1067.

29

A

Useful Theorems

We present useful theorems that we will frequently employ in our proofs.
Theorem A.1. Perturbation of singular values.
Let A and B be two m × n matrices. Let k = min{m, n}. Let λ1 , . . . , λk be the singular values of A in
decreasing order and repeated by multiplicities, and let τ1 , . . . , τk be the singular values of B in decreasing
order and repeated by multiplicities. Let δ1 , . . . , δk be the singular values of A − B, in any order but still
repeated by multiplicities. Then,
max |λi − τi | ≤ max |δi |.

1≤i≤k

1≤i≤k

References for the proof of the above result can be found in [16], for example.
Theorem A.2. Poincaré separation Theorem.
Let A be a symmetric n × n matrix. Let B be the m × m matrix with m ≤ n, where B = P T AP for
some orthogonal projection matrix P . If the eigenvalues of A are σ1 ≤ . . . ≤ σn , and those of B are
τ1 ≤ . . . ≤ τm , then for all j < m + 1,
σj ≤ τj ≤ σn−m+j .
Remark A.2.1. In the case where B is the principal submatrix of A with dimensions (n − 1) × (n − 1),
the above Theorem is also known as Cauchy’s interlacing law.
Theorem A.3. Bernstein’s Inequality.
Suppose that X1 , . . . , Xn are independent random variables
Pn with zero mean, and M is a constant such
that |Xi | ≤ M with probability one for each i. Let S := i=1 Xi and v := Var(S). Then for any t ≥ 0,


3t2
.
P(|S| ≥ t) ≤ 2 exp −
6v + 2M t
Theorem A.4. Hoeffding’s Inequality.
Suppose that X1 ,P
. . . , Xn are independent random variables that are strictly bounded by the intervals
n
[ai , bi ]. Let S := i=1 Xi . Then for any t > 0,


2t2
.
P(|S − E[S]| ≥ t) ≤ 2 exp − Pn
2
i=1 (bi − ai )
Theorem A.5. Theorem 3.4 of [16]
Take any two numbers m and n such that 1 ≤ m ≤ n. Suppose that A = [Aij ]1≤i≤m,1≤j≤n is a matrix
whose entries are independent random variables that satisfy, for some δ 2 ∈ [0, 1],
E[Aij ] = 0,

E[A2ij ] ≤ δ 2 ,

and

|Aij | ≤ 1

a.s.

Suppose that δ 2 ≥ n−1+ζ for some ζ > 0. Then, for any ω ∈ (0, 1),
√
2
P(kAk ≥ (2 + ω)δ n) ≤ C(ζ)e−cδ n ,
where C(ζ) depends only on ω and ζ, and c depends only on ω. The same result is true when m = n
and A is symmetric or skew-symmetric, with independent entries on and above the diagonal, all other
assumptions remaining the same. Lastly, all results remain true if the assumption δ 2 ≥ n−1+ζ is changed
to δ 2 ≥ n−1 (log n)6+ζ .
Remark A.5.1. The proof of Theorem A.5 can be found in [16] under Theorem 3.4.
30

B

Useful Lemmas

We begin by proving (and providing) a series of useful lemmas that we will frequently use to derive our
desired results.
Lemma B.1. Suppose C is an m
 × n matrix composed of an m × p submatrix A and an m × (n − p)
submatrix B, i.e., C = A B . Then, the spectral (operator) norms of A and B are bounded above
by the spectral norm of C,
max{kAk, kBk} ≤ kCk.
Proof. Without loss of generality, we prove the case for kAk ≤ kCk, since the same argument applies
for kBk. By definition,
 T

A A AT B
T
C C=
.
BT A BT B
Let σ1 , . . . , σn be the eigenvalues of C T C in increasing order and repeated by multiplicities. Let
τ1 , . . . , τp be the eigenvalues of AT A in increasing order and repeated by multiplicities. By the Poincaré
separation Theorem A.2, we have for all j < p + 1,
σj ≤ τj ≤ σn−p+j .
Thus, τp ≤ σn . Since the eigenvalues of C T C and AT A are the squared singular values of C and A
respectively, we have
√
√
τp = kAk ≤ kCk = σn .
We complete the proof by applying an identical argument for the case of kBk.



Lemma B.2. Let A be any m by n matrix, and let A† be its corresponding pseudoinverse. Then, the
matrices P1 = AA† and P2 = A† A are projection matrices.
Proof. We first prove that P1 is a projection matrix. In order to show P1 is a projection matrix, we
must demonstrate that P1 satisfies two properties: namely, (1) P1 is symmetric, i.e. P1T = P1 , and (2)
P1 is idempotent, i.e. P12 = P1 .
Let A = Q1 ΣQT2 represent the SVD of A, with the pseudoinverse expressed as A† = Q2 Σ+ QT1 . As
a result,
P1 = AA†
= Q1 ΣQT2 Q2 Σ+ QT1
= Q1 ΣΣ+ QT1 .
Note that
P1T = (Q1 ΣΣ+ QT1 )T
= Q1 ΣΣ+ QT1
= P1 ,
which proves that P1 is symmetric. Furthermore,
P12 = (Q1 ΣΣ+ QT1 ) · (Q1 ΣΣ+ QT1 )
= Q1 ΣΣ+ ΣΣ+ QT1
= Q1 ΣΣ+ QT1
= P1 ,
which proves that P1 is idempotent. The same argument can be applied for P2 .
31



Lemma B.3. The eigenvalues of a projection matrix are 1 or 0.
Proof. Let λ be an eigenvalue of the projection matrix P for some eigenvector v. Then, by definition of
eigenvalues,
P v = λv.
However, by the idempotent property of projection matrices (P 2 = P ), if we multiply the above equality
by P on the left, then we have
P (P v) = P (λv)
= λ2 v.
Since v 6= 0, the eigenvalues of P can only be members R whereby λ2 = λ. Ergo, we must have that
λ ∈ {0, 1}.

Pm
T
Lemma B.4. Let A =
i=1 σi xi yi be the singular value decomposition of A with σ1 , . . . , σm in
decreasing order and with repeated multiplicities. For any choice of µ ≥ 0, let S = {i : σi ≥ µ}. Define
X
B̂ =
σi xi yiT .
i∈S

Let τ1 , . . . , τm be the singular values of B in decreasing order and repeated by multiplicities, with
τ ∗ = maxi∈S
/ τi . Then
B̂ − B ≤ τ ∗ + 2kA − Bk.
Proof. By Theorem A.1, we have that σi ≤ τi + kA − Bk for all i. Applying triangle inequality, we
obtain
B̂ − B ≤ B̂ − A + kA − Bk
= max σi + kA − Bk
i∈S
/


≤ max τi + kA − Bk + kA − Bk
i∈S
/

= τ ∗ + 2kA − Bk.

Pm

T
i=1 σi xi yi

Lemma B.5. Let A =
be the singular value decomposition of A. Fix any δ > 0 such that
µ = (1 + δ)kA − Bk, and let S = {i : σi ≥ µ}. Define
X
B̂ =
σi xi yiT .
i∈S

Then
B̂ − B ≤ (2 + δ)kA − Bk.
Proof. By the definition of µ and hence the set of singular values S, we have that
B̂ − B ≤ B̂ − A + kA − Bk
= max σi + kA − Bk
i∈S
/

≤ (1 + δ)kA − Bk + kA − Bk
= (2 + δ)kA − Bk.

32

Pm
Lemma B.6. Lemma 3.5 of [16] Let A = i=1 σi xi yiT be the singular value decomposition of A.
Fix any δ > 0 and define S = {i : σi ≥ (1 + δ)kA − Bk} such that
X
B̂ =
σi xi yiT .
i∈S

Then
B̂ − B
F

≤ K(δ)(kA − BkkBk∗ )1/2 ,

p
√
where K(δ) = (4 + 2δ) 2/δ + 2 + δ.
Proof. The proof can be found in [16].

C



Preliminaries.

To simplify the following exposition, we assume that |Mij | ≤ 1 and |Xij | ≤ 1. Recall that all entries of
the pre-intervention treatment row are observed such that Y1− = X1− = M1− + −
1 . On the other hand,
every entry within the pre- and post-intervention periods for the donor units are observed independently
of the other entries with some arbitrary probability p. Specifically, for all 2 ≤ i ≤ N and j ∈ [T ], we
define Yij = Xij if Xij is observed, and Yij = 0 otherwise. Consequently, observe that for all i > 1 and
j,
E[Yij ] = pMij
and
Var(Yij ) = E[Yij2 ] − (E[Yij ])2
2
= pE[Xij
] − (pMij )2
2
≤ p(σ 2 + Mij
) − (pMij )2
2
= pσ 2 + pMij
(1 − p)

≤ pσ 2 + p(1 − p).
Recall that p̂ denotes the proportion of observed entries in X and σ̂ 2 represents the (unbiased) sample
variance computed from the pre-intervention treatment row (12). Given the information above, we
define, for any ω ∈ (0.1, 1), three events E1 , E2 , and E3 as
E1 := {|p̂ − p| ≤ ωp/z},
E2 := { σ̂ 2 − σ 2 ≤ ωσ 2 /z},
p
E3 := {kY − pM k ≤ (2 + ω/2) T q},
2

where q = σ 2 p + p(1 − p); for reasons that will be made clear later, we choose z = 60( σ σ+1
2 ). By
Bernstein’s Inequality, we have that
P(E1 ) ≥ 1 − 2e−c1 (N −1)T p ,
for appropriately defined constant c1 . By Hoeffding’s Inequality, we obtain
P(E2 ) ≥ 1 − 2e−c2 T σ

33

2

for some positive constant c2 . Moreover, by Theorem A.5,
P(E3 ) ≥ 1 − Ce−c3 T q
as long as q = σ 2 p + p(1 − p) ≥ T −1+ζ for some ζ > 0. In other words,
p(σ 2 + 1) ≥ p(σ 2 + (1 − p))
≥ T −1+ζ .
Consequently, assuming the event E3 occurs, we require that p ≥

T −1+ζ
σ 2 +1

for some ζ > 0.

Finally, as previously discussed, we will assume that both N and T grow without bound in our
imputation analysis. However, in our forecasting analysis, only T0 → ∞.

D

Imputation Analysis

In this section, we prove that our key de-noising procedure produces a consistent estimator of the underlying mean matrix, thereby adroitly imputing the missing entries and filtering corrupted observations
within our data matrix.
Lemma D.1. Let M = [Mij ] be defined as before. Suppose f is a Lipschitz function with Lipschitz
constant L and the latent row and column feature vectors come from a compact space K of dimension d.
Then for any small enough δ > 0,
q
√
kM k∗ ≤ δ(N − 1) T + C(K, d, L) (N − 1)T δ −d ,
where C(K, d, L) is a constant that depends on K, d, and L.
Proof. The proof is a straightforward adaptation of the arguments from [[16], Lemma 3.6]; however, we
provide it here for completeness. By the Lipschitzness assumption, every entry in M = [Mij ] = [f (θi , ρj )]
is Lipschitz in both its arguments, space (i) and time (j). For any δ > 0, it is not hard to see that one
can find a finite covering P1 (δ) and P2 (δ) of K so that for any θ, ρ ∈ K, there exists θ0 ∈ P1 (δ) and
ρ0 ∈ P2 (δ) such that
|f (θ, ρ) − f (θ0 , ρ0 )| ≤ δ.
Without loss of generality, let us consider the case where P (δ) = P1 (δ) = P2 (δ). For every latent row
feature θi , let p1 (θi ) be the unique element in P (δ) that is closest to θi . Similarly, for the latent column
feature ρj , find the corresponding closest element in P (δ) and denote it by p2 (ρj ). Let B = [Bij ] be the
matrix where Bij = f (p1 (θi ), p2 (ρj )). Using the arguments from above, we have that for all i and j,
X
2
kM − BkF =
(f (θi , ρj ) − f (p1 (θi ), p2 (ρj )))2 ≤ (N − 1)T δ 2 .
i,j

Therefore,
kM k∗ ≤ kM − Bk∗ + kBk∗
(a) √
≤ N − 1kM − BkF + kBk∗
√
≤ δ(N − 1) T + kBk∗ ,
p
where (a) follows from the fact that kQk∗ ≤ rank(Q)kQkF for any real-valued matrix Q. In order to
bound the nuclear norm of B, note that (by its construction) for any two columns, say j, j 0 ∈ [N − 1], if
34

p2 (ρj ) = p2 (ρ0j ) then it follows that the columns of j and j 0 of B are identical. Thus, there can be at
most |P (δ)| distinct columns (and rows) of B. In other words, rank(B) ≤ |P (δ)|. Ergo,
p
kBk∗ ≤ |P (δ)|kBkF
p
p
≤ |P (δ)| (N − 1)T .
Due to the Lipschitzness property of f and the compactness of the latent space, it can be shown that
|P (δ)| ≤ C(K, d, L)δ −d where C(K, d, L) is a constant that depends only on K, d, and L (the Lipschitz
constant of f ).

Lemma D.2. (Theorem 1.1 of [16]) Let M̂ and M be defined as before. Suppose that p ≥
for some ζ > 0. Then using µ as defined in (20)
MSE(M̂ ) ≤



C1 kM k∗
1
√
,
+O
(N − 1)T
(N − 1) T p

where C1 is a universal positive constant.
Proof. Let δ > 0 be defined by the relation
p
(1 + δ)kY − pM k = (2 + ω) T q̂,
where q̂ = σ̂ 2 p̂ + p̂(1 − p̂). Observe that if E1 , E2 , and E3 happen, then
p
(2 + ω) T (σ̂ 2 p̂ + p̂(1 − p̂))
p
1+δ ≥
(2 + ω/2) T (σ 2 p + p(1 − p))
p
p
(2 + ω) 1 − ω/z (1 − ω/z)σ 2 p + p(1 − p − ωp/z)
p
≥
(2 + ω/2) σ 2 p + p(1 − p)
s
p
(2 + ω) 1 − ω/z
ω  σ2 + p 
=
1−
2 + ω/2
z σ2 + 1 − p
r
p
(2 + ω) 1 − ω/z
ω  σ2 + 1 
≥
1−
2 + ω/2
z
σ2
p
r
(2 + ω) 1 − ω/z
ω
=
1−
2 + ω/2
60
ω
2+ω 
1−
≥
2 + ω/2
60

ω 
ω
≥ 1+
1−
5
60
ω
1
≥1+ − .
5
50
Let K(δ) be the constant defined in Lemma B.6. Since ω ∈ (0.1, 1), δ ≥

10ω−1
50

p
√
K(δ) = (4 + 2δ) 2/δ + 2 + δ
p
p
p
√
≤ 4 1 + δ 2/δ + 2 2(1 + δ) + 2(1 + δ)
p
√ √
= (4 2/δ + 3 2) 1 + δ
√
≤ C1 1 + δ

35

> 0 and

T −1+ζ
σ 2 +1

where C1 is a constant that depends only on the choice of ω. By Lemma B.6, if E1 , E2 and E3 occur,
then
2

p̂M̂ − pM
F

≤ C2 (1 + δ)kY − pM kkpM k∗
p
≤ C3 T q̂kpM k∗
p
≤ C4 T qkpM k∗

for an appropriately defined constant C4 . Therefore,
2

p2 M̂ − M

F

≤ C5 p̂2 M̂ − M

2
F
2

2

+ C5 (p̂ − p)2 kM kF
≤ C5 p̂M̂ − pM
F
p
≤ C6 T qkpM k∗ + C5 (p̂ − p)2 (N − 1)T,
where the last inequality follows from the boundedness assumption of M . In general, since |Mij | and
|Yij | ≤ 1,
M̂ − M
F

≤ M̂
+ kM kF
F
p
≤ |S| M̂ + kM kF
p
|S|
=
kY k + kM kF
p̂
≤ (N − 1)3/2 T kY k + kM kF
p
p
≤ (N − 1)3/2 T (N − 1)T + (N − 1)T
≤ 2(N − 1)2 T 3/2 .

Let E := E1 ∩ E2 ∩ E3 . Applying DeMorgan’s Law and the Union Bound,
P(E c ) = P(E1c ∪ E2c ∪ Eec )
≤ P(E1c ) + P(E2c ) + P(E3c )
≤ C7 e−c8 T (p(N −1)+σ

2

+q)

= C7 e−c8 φT ,

(48)

where we define φ := p(N − 1) + σ 2 + q and C7 , c8 are appropriately defined. Observe that E(p̂ − p)2 =
p(1−p)
(N −1)T . Thus, by the law of total probability and noting that P(E) ≤ 1 (for appropriately defined
constants),
2

E M̂ − M

F

h
i
h
i
2
2
≤ E M̂ − M
| E + E M̂ − M
| E c P(E c )
F
F
p
≤ C6 p−1 T qkM k∗ + C5 p−1 (1 − p) + C9 (N − 1)4 T 3 e−c8 φT
= C6 p−1/2 T 1/2 (σ 2 + (1 − p))1/2 kM k∗ + C5 p−1 (1 − p) + C9 (N − 1)4 T 3 e−c8 φT .

Normalizing by (N − 1)T , we obtain
MSE(M̂ ) ≤

C12 kM k∗
C5 (1 − p)
√
+
+ C10 e−c11 φT .
(N − 1) T p (N − 1)T p

The proof is complete assuming constants are re-named.
36



D.1

Proof of Theorem 4.1

Theorem (4.1). (Theorem 2.1 of [16]) Suppose that M is rank k. Suppose that p ≥
ζ > 0. Then using µ as defined in (20),
s


k
1
,
MSE(M̂ ) ≤ C1
+O
(N − 1)p
(N − 1)T

T −1+ζ
σ 2 +1

for some

where C1 is a universal positive constant.
Proof. By the low rank assumption of M , we have that
p
kM k∗ ≤ rank(M )kM kF
p
≤ k(N − 1)T .
The proof follows from a simple application of Lemma D.2.

D.2



Proof of Theorem 4.2

Theorem (4.2). (Theorem 2.7 of [16]) Suppose f is a L-Lipschitz function. Suppose that p ≥
for some ζ > 0. Then using µ as defined in (20),

T −1+ζ
σ 2 +1

1

MSE(M̂ ) ≤ C(K, d, L)



1
(N − 1)− d+2
+O
,
√
p
(N − 1)T

where C(K, d, L) is a constant depending on K, d, and L.
Proof. Since f is Lipschitz, we invoke Lemmas D.1 and D.2 and choose δ = (N − 1)−1/(d+2) . This
completes the proof.


E

Forecasting Analysis: Pre-Intervention Regime

Here, we will bound the pre-intervention `2 error of our estimator in order to measure its prediction
power.

E.1

Linear Regression

In this section, we will analyze the performance of our algorithm when learning β ∗ via linear regression,
i.e. η = 0. As a result, we will temporarily drop the dependency on η in this subsection such that
β̂ = β̂(0). To ease the notational complexity of the following Lemma E.1 proof, we will make use of the
following notations for only in this subsection:
Q := (M − )T

(49)

− T

Q̂ := (M̂ )

(50)

M1− := Qβ ∗

(51)

M̂1−

(52)

such that

:= Q̂β̂.
37

2
∗
Lemma E.1. Suppose Y1− = M1− + −
1 with E[1j ] = 0 and Var(1j ) ≤ σ for all j ∈ [T0 ]. Let β be
defined as in (6) and let β̂ be the minimizer of (10). Then for any µ ≥ 0 and η = 0,

E M1− − M̂1−

2

≤ E (M − − M̂ − )T β ∗

2

+ 2σ 2 |S|.

(53)

−
∗
Proof. Recall that for the treatment row, Y1− = M1− + −
1 with M1 = Qβ . Since β̂, by definition,

minimizes Y1− − Q̂v for any v ∈ RN −1 , we subsequently have
M1− − M̂1−

2

= (Y1− − −
1 ) − Q̂β̂

2

2

= (Y1− − Q̂β̂) + (−−
1)
2

= Y1− − Q̂β̂
≤ Y1− − Q̂β ∗

2

+ −
1
2

2

∗
= (Qβ ∗ + −
1 ) − Q̂β

= (Q − Q̂)β ∗

2

2

+ −
1

= (Q − Q̂)β ∗ + −
1

2

−
+ 2h−−
1 , Y1 − Q̂β̂i
−
+ 2h−−
1 , Y1 − Q̂β̂i

+ −
1

+ −
1
2

+ 2 −
1

2

2

−
+ 2h−−
1 , Y1 − Q̂β̂i

−
+ 2h−−
1 , Y1 − Q̂β̂i

−
−
∗
+ 2h−
1 , (Q − Q̂)β i + 2h−1 , Y1 − Q̂β̂i.

Taking expectations, we arrive at the inequality
E M̂1− − M1−

2

≤ E (Q − Q̂)β ∗

2

+ 2E −
1

2

−
−
∗
+ 2E[h−
1 , (Q − Q̂)β i] + 2E[h−1 , Y1 − Q̂β̂i].

(54)

We will now deal with the two inner products on the right hand side of equation (54). First, observe that
− T
− T
∗
∗
∗
E[h−
1 , (Q − Q̂)β i] = E[(1 ) ]Qβ − E[(1 ) Q̂]β
T
∗
= −E[(−
1 ) ]E[Q̂]β

= 0,
since the additive noise terms are independent random variables that satisfy E[ij ] = 0 for all i and j
by assumption, and Q̂ := (M̂ − )T depends only on the noise terms for i 6= 1; i.e., the construction of
Q̂ := (M̂ − )T excludes the first row (treatment row), and thus depends solely on the donor pool.
T
† −
For the other inner product term, we begin by recognizing that (−
1 ) Q̂Q̂ 1 is a scalar random
variable, which allows us to replace the random variable by its own trace. This is useful since the trace
operator is a linear mapping and is invariant under cyclic permutations, i.e., tr(AB) = tr(BA). As a
result,
− T
T
† −
† −
E[(−
1 ) Q̂Q̂ 1 ] = E[tr((1 ) Q̂Q̂ 1 )]
− T
= E[tr(Q̂Q̂† −
1 (1 ) )]


− T
= tr E[Q̂Q̂† −
(
)
]
1
1


− − T
†
= tr E[Q̂Q̂ ]E[1 (1 ) ]


≤ tr E[Q̂Q̂† ]σ 2 I

= σ 2 E[tr(Q̂Q̂† )]
(a)

= σ 2 E[rank(Q̂)]

≤ σ 2 |S|,
38

where (a) follows from the fact that Q̂Q̂† is a projection matrix by Lemma B.2. As a result, Q̂Q̂† has
rank(Q̂) eigenvalues equal to 1 and all other eigenvalues equal to 0 (by Lemma B.3), and since the trace
of a matrix is equal to the sum of its eigenvalues, tr(Q̂Q̂† ) = rank(Q̂). Simultaneously, by the definition
of Q̂ := (M̂ − )T , we have that the rank of Q̂ := (M̂ − )T is at most |S|. Returning to the second inner
product and recalling β̂ = Q̂† Y1− ,
−
E[h−−
1 , Y1 − Q̂β̂i]

− T −
T
= E[(−
1 ) Q̂β̂] − E[(1 ) Y1 ]
− T
−
− T −
T
† −
= E[(−
1 ) Q̂Q̂ Y1 ] − E[(1 ) ]M1 − E[(1 ) 1 ]
−
− T
− T −
T
†
† −
= E[(−
1 ) Q̂Q̂ ]M1 + E[(1 ) Q̂Q̂ 1 ] − E[(1 ) 1 ]
(a)

−
− T
− T −
T
†
† −
= E[(−
1 ) ]E[Q̂Q̂ ]M1 + E[(1 ) Q̂Q̂ 1 ] − E[(1 ) 1 ]

−
T
† −
= E[(−
1 ) Q̂Q̂ 1 ] − E 1

≤ σ 2 |S| − E −
1

2

2

,

where (a) follows from the same independence argument used in evaluating the first inner product.
Finally, we incorporate the above results to (54) to arrive at the inequality
E M̂1− − M1−

2

≤ E (Q − Q̂)β ∗
= E (Q − Q̂)β ∗

2

2

+ 2E −
1

2

+ 2(σ 2 |S| − E −
1

2

)

+ 2σ 2 |S|.


Lemma E.2. For η = 0 and any µ ≥ 0, the pre-intervention error of the algorithm can be bounded as
MSE(M̂1− ) ≤

2 2σ 2 |S|
C1  ∗
E λ + kY − pM k + (p̂ − p)M −
+ C2 e−cp(N −1)T .
+
2
p T0
T0

(55)

Here, λ1 , . . . , λN −1 are the singular values of pM in decreasing order and repeated by multiplicities, with
λ∗ = maxi∈S
/ λi ; C1 , C2 and c are universal positive constants.
Proof. Recall that E1 := {|p̂ − p| ≤

ωp
z }

for some choice of ω ∈ (0.1, 1). Thus, under the event E1 ,

p M̂ − − M − ≤ C1 p̂ M̂ − − M −


≤ C1 p̂M̂ − − pM − + (p̂ − p)M −


(a)
≤ C1 p̂M̂ − pM + (p̂ − p)M −


(b)
≤ C1 λ∗ + 2kY − pM k + (p̂ − p)M −
where (a) follows from Lemma B.1 and (b) follows from Lemma B.4. In general, since |Mij | and |Yij | ≤ 1,
M̂ − − M −

(a)

≤ M̂ + M −

1
kY k + M −
p̂
≤ (N − 1)T kY k + M −
p
p
≤ (N − 1)T (N − 1)T + (N − 1)T0

=

≤ 2((N − 1)T )3/2 .
39

(56)

(a) follows from a simple application of Lemma B.1 and the triangle inequality of operator norms. By
the law of total probability and P(E1 ) ≤ 1,
h
i
h
i
2
2
2
E (M̂ − − M − )T β ∗ ≤ E (M̂ − − M − )T β ∗ | E1 + E (M̂ − − M − )T β ∗ | E1c P(E1c )
i
h
i
(a) h
2
2
2
2
≤ E M̂ − − M − | E1 kβ ∗ k + E M̂ − − M − | E1c kβ ∗ k P(E1c )
2
i
C2 h
| E1 + C3 ((N − 1)T )3/2 e−cp(N −1)T ,
≤ 2 E λ∗ + 2kY − pM k + (p̂ − p)M −
p
where (a) follows because the spectral norm is an induced norm, and the last inequality makes use of
the results from above. Note that C2 and C3 are appropriately defined to depend on β ∗ . Moreover, for
any non-negative valued random variable X and event E with P(E) ≥ 1/2,
E[X | E] ≤

E[X]
≤ 2E[X].
P(E)

(57)

Using the fact that P(E1 ) ≥ 1/2 for large enough T, N , we apply Lemma E.1 to obtain (with appropriately
defined constants C4 , C5 , c6 )
2
1
2σ 2 |S|
E (M − − M̂ − )T β ∗ +
T0
T0
2 2σ 2 |S|

C4
+
≤ 2 E λ∗ + kY − pM k + (p̂ − p)M −
+ C5 e−c6 p(N −1)T .
p T0
T0

MSE(M̂1− ) ≤

The proof is completed assuming we re-label constants C4 , C5 , c6 as C1 , C2 , and c, respectively.

E.2

(58)


Ridge Regression

In this section, we will prove our results for the ridge regression setting, i.e. η > 0. Let us begin by
deriving the closed form expression of β̂(η).
Derivation of β̂(η). We derive the closed form solution for β̂(η) under the new objective function with
the additional complexity penalty term:
Y1− − (M̂ − )T v

2

2

+ ηkvk = (Y1− )T Y1− − 2v T M̂ − Y1− + v T M̂ − (M̂ − )T v + ηv T v.

Setting the gradient of the above expression to zero and solving for v, we obtain
(
)
∇v

Y1− − (M̂ − )T v

2

2

= −2M̂ − Y1− + 2M̂ − (M̂ − )T v + 2ηv = 0.

+ ηkvk

v=β̂(η)

Therefore,

−1
β̂(η) = M̂ − (M̂ − )T + ηI
M̂ − Y1− .
Remark E.0.1. To ease the notational complexity of the following Lemmas E.3 and E.5 proofs, we will
make use of the following notations for only this derivation: Let
Q := (M − )T

(59)

Q̂ := (M̂ − )T

(60)

M1− := Qβ ∗

(61)

M̂1−

(62)

such that

:= Q̂β̂.
40

Lemma E.3. Let Pη = Q̂(Q̂T Q̂ + ηI)−1 Q̂T denote the projection matrix under the quadratic regularization setting. Then, the non-zero singular values of Pη are s2i /(s2i + η) for all i ∈ S.
Proof. Recall that the singular values of Y are si , while the singular values of Q̂ are those si ≥ µ. Let
Q̂ = U ΣV T be the singular value decomposition of Q̂. Since V V T = I, we have that
Pη = Q̂(Q̂T Q̂ + ηI)−1 Q̂T
= U ΣV T (V Σ2 V T + ηI)−1 V ΣU T
= U ΣV T (V Σ2 V T + ηV V T )−1 V ΣU T
= U ΣV T V (Σ2 + ηI)−1 V T V ΣU T
= U Σ(Σ2 + ηI)−1 ΣU T
= U DU T ,
where
!
s2|S|
s21
D = diag 2
,..., 2
, 0, . . . , 0 .
s1 + η
s|S| + η

2
∗
Lemma E.4. Suppose Y1− = M1− + −
1 with E[1j ] = 0 and Var(1j ) ≤ σ for all j ∈ [T0 ]. Let β be
−
− T ∗
defined as in (6), i.e. M1 = (M ) β , and let β̂(η) be the minimizer of (10). Then for any µ ≥ 0 and
η > 0,
2

E M1− − M̂1−

≤ E (M − − M̂ − )T β ∗

2

2

+ ηkβ ∗ k − ηE β̂(η)

2

+ 2σ 2 |S|.

(63)

Proof. The following proof is a slight modification for the proof of Lemmas E.1. In particular, observe
2
that β̂(η) minimizes Y1− − Q̂v + ηkvk for any v ∈ RN −1 . As a result,
M1− − M̂1−

2

2

+ η β̂(η)

= (Y1− − −
1 ) − Q̂β̂(η)

2

2

+ η β̂(η)

= (Y1− − Q̂β̂(η)) + (−−
1)
= Y1− − Q̂β̂(η)
≤ Y1− − Q̂β ∗

2

2

2

+ −
1
2

2

+ ηkβ ∗ k + −
1

= (Q − Q̂)β ∗ + −
1
2

2

+ η β̂(η)

+ η β̂(η)

∗
= (Qβ ∗ + −
1 ) − Q̂β

= (Q − Q̂)β ∗

2

2

2

2

−
+ 2h−−
1 , Y1 − Q̂β̂(η)i

−
+ 2h−−
1 , Y1 − Q̂β̂(η)i

2

+ ηkβ ∗ k + −
1
2

+ ηkβ ∗ k + −
1
2

+ ηkβ ∗ k + 2 −
1

2

2

2

−
+ 2h−−
1 , Y1 − Q̂β̂(η)i

−
+ 2h−−
1 , Y1 − Q̂β̂(η)i

−
−
∗
+ 2h−
1 , (Q − Q̂)β i + 2h−1 , Y1 − Q̂β̂(η)i

Taking expectations, we have
E M̂1− − M1−

2

≤ E (Q − Q̂)β ∗

2


2
+ η kβ ∗ k − E β̂(η)

2

+ 2E −
1

41

2

−
−
∗
+ 2Eh−
1 , (Q − Q̂)β i + 2Eh−1 , Y1 − Q̂β̂(η)i.

∗
As before, we have that Eh−
1 , (Q − Q̂)β i = 0 by the zero-mean and independence assumptions of the
noise random variables. Similarly, note that
− T
T
T
−1 T −
E[(−
Q̂ Y1 ]
1 ) Q̂β̂(η)] = E[(1 ) Q̂(Q̂ Q̂ + ηI)
T
T
−1 T
T
T
−1 T −
= E[(−
Q̂ ]M1− + E[(−
Q̂ 1 ]
1 ) Q̂(Q̂ Q̂ + ηI)
1 ) Q̂(Q̂Q̂ + ηI)
T
T
−1 T −
= E[(−
Q̂ 1 ]
1 ) Q̂(Q̂ Q̂ + ηI)
T
T
−1 T −
= E[tr((−
Q̂ 1 )]
1 ) Q̂(Q̂ Q̂ + ηI)
− T
= E[tr(Q̂(Q̂T Q̂ + ηI)−1 Q̂T −
1 (1 ) )]
− T
= tr(E[Q̂(Q̂T Q̂ + ηI)−1 Q̂T −
1 (1 ) ])
− T
= tr(E[Q̂(Q̂T Q̂ + ηI)−1 Q̂T ]E[−
1 (1 ) ])

≤ σ 2 E[tr(Q̂(Q̂T Q̂ + ηI)−1 Q̂T )]
(a)

≤ σ 2 E[tr(Q̂Q̂† )]

(b)

= σ 2 rank(Q̂)

≤ σ 2 |S|,
where (a) follows from Lemma E.3, and as before, (b) follows because Q̂Q̂† is a projection matrix. 
Lemma E.5. For any η > 0 and µ ≥ 0, the pre-intervention error of the regularized algorithm can be
bounded as
MSE(M̂1− ) ≤

2 2σ 2 |S| ηkβ ∗ k2
C1  ∗
−
(p̂
−
p)M
+
E
λ
+
kY
−
pM
k
+
+
+ C2 e−cp(N −1)T .
p2 T0
T0
T0

Here, λ1 , . . . , λN −1 are the singular values of pM in decreasing order and repeated by multiplicities, with
λ∗ = maxi∈S
/ λi ; C1 , C2 and c are universal positive constants.
Proof. The proof follows the same arguments as that of Lemma E.2.

E.3
E.3.1



Combining linear and ridge regression.
Proof of Theorem 4.3

Theorem (4.3). For any η ≥ 0 and µ ≥ 0, the pre-intervention error of the algorithm can be bounded as
MSE(M̂1− ) ≤

2 2σ 2 |S| ηkβ ∗ k2
C1  ∗
−
E
λ
+
kY
−
pM
k
+
(p̂
−
p)M
+
+
+ C2 e−cp(N −1)T .
p2 T0
T0
T0

Here, λ1 , . . . , λN −1 are the singular values of pM in decreasing order and repeated by multiplicities, with
λ∗ = maxi∈S
/ λi ; C1 , C2 and c are universal positive constants.
Proof. The proof follows from a simple amalgamation of Lemmas E.2 and E.5.
E.3.2



Proof of Corollary 4.1
−1+ζ

Corollary (4.1). Suppose p ≥ Tσ2 +1 for some ζ > 0. Let T ≤ αT0 for some constant α > 1. Then for
any η ≥ 0 and using µ as defined in (20), the pre-intervention error is bounded above by

42

MSE(M̂1− ) ≤

p
C1 2
(σ + (1 − p)) + O(1/ T0 ),
p

where C1 is a universal positive constant.
√
Proof. Since the singular value threshold µ = (2 + ω) T q̂, let us define δ so that
p
(1 + δ)kY − pM k = (2 + ω) T q̂,
where q̂ = σ̂ 2 p̂ + p̂(1 − p̂); recall that q = σ 2 p + p(1 − p). If E3 happens, then we know that δ ≥ 0.
Therefore, assuming E1 , E2 , and E3 happens, Lemma B.5 states that
p̂M̂ − pM ≤ (2 + δ)kY − pM k
≤ 2(1 + δ)kY − pM k
p
= (4 + 2ω) T q̂
p
≤ C1 T q

(64)

for an appropriately defined constant C1 . Therefore,
p M̂ − − M − ≤ C2 p̂ M̂ − − M −


≤ C2 p̂M̂ − − pM − + (p̂ − p)M −


(a)
≤ C2 p̂M̂ − pM + (p̂ − p)M −
 p

≤ C2 C1 T q + (p̂ − p)M −

(65)

where (a) follows from Lemma B.1. Applying the logic that led to (56), we have that, in general,
M̂ − − M − ≤ 2((N − 1)T )3/2 .

(66)

Let E := E1 ∩ E2 ∩ E3 . Further, using the same argument that led to (48), we have
P(E c ) ≤ C3 e−c4 φT
where we define φ := p(N − 1) + σ 2 + q and C3 , c4 are appropriately defined. Thus, by the law of total
probability and noting that P(E) ≤ 1,
h
i
h
i
2
2
2
E (M̂ − − M − )T β ∗ ≤ E (M̂ − − M − )T β ∗ | E + E (M̂ − − M − )T β ∗ | E c P(E c )
i
h
i
(a) h
2
2
2
2
≤ E M̂ − − M − | E kβ ∗ k + E M̂ − − M − | E c kβ ∗ k P(E c )
2
i
C5 hp
≤ 2E
T q + (p̂ − p)M −
| E + C6 ((N − 1)T )3/2 e−c4 φT ,
(67)
p
where (a) follows because the spectral norm is an induced norm and the last inequality makes use of the
results from above. Note that C5 and C6 are appropriately defined to depend on β ∗ . Using the fact
that P(E) ≥ 1/2 for large enough T, N , we apply Lemmas E.1 and E.5 as well as (57) to obtain (with
appropriately defined constants C7 , C8 , c9 )
2

2
1
2σ 2 |S| ηkβ ∗ k
E (M − − M̂ − )T β ∗ +
+
T0
T0
T0
2


2
2
p
C7
2σ (N − 1) ηkβ ∗ k
≤ 2 E
T q + (p̂ − p)M −
+
+
+ C8 e−c9 φT .
p T0
T0
T0

MSE(M̂1− ) ≤

43

(68)

p(1−p)
Var(p̂) where Var(p̂) = (N
−1)T . Therefore,
p
 q 1/2 p(1 − p)
p
√
E
T q (p̂ − p)M − ≤
M−
N −1
p
≤ qp(1 − p)T0 .

From Jensen’s Inequality, E|p̂ − p| ≤

p

At the same time,
E (p̂ − p)M −

2

= E(p̂ − p)2 · M −

2

p(1 − p)T0
T
≤ p(1 − p).
≤

Putting everything together, we arrive at the inequality
2

MSE(M̂1− ) ≤

 2σ 2 (N − 1) ηkβ ∗ k
p
C7 
qT + p(1 − p) + 2 qp(1 − p)T0 +
+
+ C8 e−c9 φT
2
p T0
T0
T0
2

C10 q C7 (1 − p) C11 (q(1 − p))1/2
2σ 2 (N − 1) ηkβ ∗ k
√
+
+
+
+
+ C8 e−c9 φT
p2
pT0
T0
T0
p3/2 T0
p
C10 2
(σ + (1 − p)) + O(1/ T0 ).
=
p
=

The proof is complete assuming we re-label C10 as C1 .
E.3.3



Proof of Theorem 4.4
1

Theorem (4.4). Fix any γ ∈ (0, 1/2) and ω ∈ (0.1, 1). Let ∆ = T02
Suppose p ≥

T0−2γ
σ 2 +1

+γ

q
and µ = (2+ω) T02γ (σ̂ 2 p̂ + p̂(1 − p̂)).

is known. Then for any η ≥ 0,
ˆ − ) = O(T −1/2+γ ).
MSE(M̄
1
0

Proof. To establish Theorem 4.4, we shall follow the proof of Corollary 4.1, using the block partitioned
1/2+γ
matrices instead. Recall that τ = T0 /∆ where ∆ = T0
. For analytical simplicity, we define the
random variable
(
1 w.p. p,
Dit =
0 otherwise,
whose definition will soon prove to be useful. As previously described in Section 4, for all i > 1 and
j ∈ [∆], we define
1 X
X̄ij =
Xit · Dit
τ
t∈Bj

and
M̄ij =

p X
Mit .
τ
t∈Bj

Let us also define Ē − = [¯
ij ]2≤i≤N,j≤∆ with entries
1 X
¯ij =
it · Dit .
τ
t∈Bj

44

(69)

For the first row (treatment unit), since we know p by assumption, we define for all j ∈ [∆]
p X
X1t
τ
t∈Bj
p X
=
(M1t + 1t )
τ
t∈Bj
p X
p X
=
M1t +
1t
τ
τ

X̄1j =

t∈Bj

(70)

t∈Bj

= M̄1j + ¯1j ,
(71)
P
whereby M̄1j = τp t∈Bj M1t and ¯1j = τp t∈Bj 1t . Under these constructions, the noise entries remain
zero-mean random variables for all i, j, i.e. E[¯
ij ] = 0. However, the variance of each noise term is now
rescaled, i.e. for i = 1
P

Var(¯
1j ) =

p2 X
Var(1t )
τ2
t∈Bj

2

≤

σ
,
τ

and for i > 1,
1 X
Var(it · Dit )
τ2

Var(¯
ij ) =

t∈Bj

(a)

≤

1 X 2
(σ p(1 − p) + σ 2 p2 )
τ2
t∈Bj

2

≤

σ
.
τ

(a) used the fact that for any two independent random variables, X and Y , Var(XY ) = Var(X)Var(Y ) +
Var(X)(E[Y ])2 + Var(Y )(E[X])2 . Thus, for all i, j, Var(¯
ij ) ≤ σ 2 /τ := σ̄ 2 .
We now show that the key assumption of (6) still holds under this setting with respect to the newly
defined variables. In particular, for every partition j ∈ [∆] of row one,
M̄1j =

p X
M1t
τ
t∈Bj

N

p X X ∗
=
βk Mkt
τ
t∈Bj

=

N
X

βk∗

k=2

p X

k=2

=

N
X

τ

Mkt



t∈Bj

βk∗ M̄kj .

k=2

As a result, we can express M̄1− = (M̄ − )T β ∗ for the same β ∗ as in (6).
Following a similar setup as before, we define the matrix Ȳ − = [Ȳij ]2≤i≤N,j≤∆ . Since we have
assumed that each block contains at least one observed entry, we subsequently have that Ȳij = X̄ij for
all i and j. We now proceed with our analysis in the exact same manner with the only difference being
45

our newly defined set of variables and parameters. For completeness, we will highlight certain details
below.
To begin, observe that E[Ȳij ] = M̄ij while
Var(Ȳij ) ≤

σ 2 p + p(1 − p)
.
τ

√
Consequently, we redefine the event E3 := { Ȳ − − M̄ − ≤ (2 + ω) ∆q̄} for some choice ω ∈ (0.1, 1)
and for q̄ =

σ 2 p+p(1−p)
.
τ

By Theorem A.5, it follows that P(E3 ) ≥ 1 − C 0 e−cq̄∆ .

Similar to before, let δ be defined by the relation
q
(1 + δ) Ȳ − − M̄ − = (2 + ω) ∆q̄ˆ,
2

p̂)
. Letting E = E1 ∩ E2 ∩ E3 and using arguments ((64), (65), (56)) that led us to
where q̄ˆ = σ̂ p̂+p̂(1−
τ
(67), we obtain

ˆ − − M̄ − )T β ∗
E (M̄

2

h
ˆ − − M̄ − )T β ∗
≤ E (M̄

2

i
h
ˆ − − M̄ − )T β ∗
| E + E (M̄

2

i
| E c P(E c )

≤ C1 ∆q̄ + C2 e−c3 φ∆ ,
where φ := p(N − 1) + σ 2 + q̄. Utilizing Lemmas E.1 and E.5 gives us (for appropriately defined constants
and defining q = σ 2 p + p(1 − p) as before such that q̄ = q/τ )
2

2
∗
ˆ − ) ≤ C q̄ + 2σ̄ k + ηkβ k + C e−c5 φ∆ .
MSE(M̄
1
4
1
∆
∆
2
q
C1 q 2σ 2 k ηkβ ∗ k
+
+
+ C4 e−c5 τ ∆
=
τ
τ∆
∆
2
2γ
C1 q
2σ 2 k ηkβ ∗ k
= 1/2−γ +
+ 1/2+γ + C4 e−c5 qT0
T
0
T
T
0

0

−1/2+γ

= O(T0

).

This concludes the proof.

F



Forecasting Analysis: Post-Intervention Regime

We now bound the post-intervention `2 error of our estimator.

F.1

Proof of Theorem 4.5

Theorem (4.5). Let (6) hold for some β ∗ ∈ RN −1 . Let rank(M − ) = rank(M ). Then M1+ = (M + )T β ∗ .
Proof. Suppose we begin with only the matrix M − , i.e. M = M − . From the assumption that
M1− = (M − )T β ∗ , we have for t ≤ T0
M1t =

N
X
j=2

46

βj∗ Mjt .

Suppose that we now add an extra column to M − so that M is of dimension N × (T0 + 1). Since
rank(M − ) = rank(M ), we have for j ∈ [N ]
Mj,T0 +1 =

T0
X

πt Mjt ,

t=1

for some set of weights π ∈ RT0 . In particular, for the first row we have
M1,T0 +1 =

T0
X

πt M1t

t=1

=

=

T0
X

πt

t=1

j=2

N
X

T0
X

βj∗

N
X

βj∗ Mjt



πt Mjt



t=1

j=2

=

N
X

βj∗ Mj,T0 +1 .

j=2

By induction, we observe that for any number of columns added to M − such that rank(M − ) = rank(M ),
we must have M1+ = (M + )T β ∗ where M + = [Mit ]2≤i≤N,T0 <t≤T .


F.2

Proof of Theorem 4.6

Theorem (4.6). Suppose p ≥
0

T −1+ζ
σ 2 +1

for some ζ > 0. Suppose β̂(η)
0

∞

≤ ψ for some ψ > 0. Let

α T0 ≤ T ≤ αT0 for some constants α , α > 1. Then for any η ≥ 0 and using µ as defined in (20), the
post-intervention error is bounded above by
p
C1
C2 kM k
RMSE(M̂1+ ) ≤ √ (σ 2 + (1 − p))1/2 + √
· E β̂(η) − β ∗ + O(1/ T0 ),
p
T0
where C1 and C2 are universal positive constants.
Proof. We will prove Theorem 4.6 by drawing upon techniques and results from prior proofs. We begin
by applying triangle inequality to obtain
M̂1+ − M1+ = (M̂ + )T β̂(η) − (M + )T β ∗
= (M̂ + )T β̂(η) − (M + )T β ∗ + (M + )T β̂(η) − (M + )T β̂(η)
≤ (M̂ + − M + )T β̂(η) + (M + )T (β̂(η) − β ∗ ) .
Taking expectations and using the property of induced norms gives
h
i
E M̂1+ − M1+ ≤ E M̂ + − M + · β̂(η) + M + · E β̂(η) − β ∗
√
≤ N ψ · E M̂ + − M + + M + · E β̂(η) − β ∗ ,

(72)

where the last inequality uses the boundedness assumption of β̂(η). Observe that the first term on the
right-hand side of (72) is similar to that of (53) and (63) with the main difference being (72) uses the
47

post-intervention submatrices, M̂ + and M + , as opposed to the pre-intervention submatrices, M̂ − and
M − , in (53) and (63). Therefore, using (57) and the arguments that led to (67), it follows that (with
appropriate constants C1 , C2 , c3 )
E M̂ + − M + ≤


C1 p
E
T q + (p̂ − p)M + + C2 ((N − 1)T )3/2 e−c3 φT ,
p

where the slight modification arises due to the fact that we are now operating in the post-intervention
p
regime. In particular, kM + k ≤ (N − 1)(T − T0 ) and M̂ + ≤ ((N − 1)T )3/2 . Further, note that q
and φ are defined exactly as before, i.e. q = σ 2 p + p(1 − p) and φ = p(N − 1) + σ 2 + q. Following the
proof of Corollary 4.1, we apply Jensen’s Inequality to obtain
E (p̂ − p)M + = E|p̂ − p| · M +
s
p(1 − p) p
≤
· (N − 1)(T − T0 )
(N − 1)T
p
≤ p(1 − p).
Putting the above results together, we have (for appropriately defined constants)
√

p
C1 N ψ p
kM + k
+
RMSE(M̂1 ) ≤ √
T q + p(1 − p) + √
· E β̂(η) − β ∗ + C4 e−c5 φT
p T − T0
T − T0
√
√
(a) C6 q
C7 1 − p C8 kM k
≤
+ √
+ √
· E β̂(η) − β ∗ + C4 e−c5 φT
p
pT0
T0
p
C6
C8 kM k
= √ (σ 2 + (1 − p))1/2 + √
· E β̂(η) − β ∗ + O(1/ T0 ),
p
T0
where (a) follows from Lemma B.1. Renaming constants would provide the desired result.

G



A Bayesian Perspective

Derivation of posterior parameters.
The following is based on the derivation presented in Section 2.2.3 of [12], and is presented here for
completeness. Suppose we are given a multivariate Gaussian marginal distribution p(x) paired with a
multivariate Gaussian conditional distribution p(y | x) – where x and y may have differing dimensions –
and we are interested in computing the posterior distribution over x, i.e. p(x | y). We will derive the
posterior parameters of p(x | y) here. Without loss of generality, suppose
p(x) = N (x | µ, Λ−1 )
p(y | x) = N (y | Ax + b, Σ−1 ),
where µ, A, and b are parameters that govern the means, while Λ and Σ are precision (inverse covariance)
matrices.
We begin by finding the joint distribution over x and y. Ignoring the terms that are independent of

48

x and y and encapsulating them into the “const.” expression, we obtain
ln p(x, y) = ln p(x) + ln p(y | x)
1
= − (x − µ)T Λ(x − µ) −
2
1
= − xT (Λ + AT ΣA)x −
2
 T 
1 x
Λ + AT ΣA
=−
−ΣA
2 y
1 T
= − z Qz + const.,
2

1
(y − Ax − b)T Σ(y − Ax − b) + const.
2
1 T
1
y Σy + xT AT Σy + const.
2
2
 
T
−A Σ x
+ const.
y
Σ

where z = [x, y]T , and
Q=



Λ + AT ΣA −AT Σ
−ΣA
Σ

is the precision matrix. Applying the matrix inversion formula, we have that the covariance matrix of z
is
 −1

Λ
Λ−1 AT
−1
Var(z) = Q =
.
AΛ−1 Σ−1 + AΛ−1 AT
After collecting the linear terms over z, we find that the mean of the Gaussian distribution over z is
defined as


T
−1 Λµ − A Σb
E[z] = Q
.
Σb
Now that we have the parameters over the joint distribution of x and y, we find that the posterior
distribution parameters over x are
E[x | y] = (Λ + AT ΣA)−1 {AT Σ(y − b) + Λµ}
Var(x | y) = (Λ + AT ΣA)−1 .

49

